<?xml version="1.0" encoding="utf-8"?>
<FDL version="2.1">
  <TypeDefinition url="..\default_typedef.xml"/>
  <Form id="Functions" classname="Functions" left="0" top="0" width="980" height="770" titletext="다양한그리드기능" onload="Functions_onload" ontimer="Functions_ontimer">
    <Layouts>
      <Layout width="980" height="770">
        <Grid id="grdList" taborder="0" useinputpanel="false" left="0" top="240" right="20" cellmovingtype="col" cellsizingtype="col" binddataset="dsList" bottom="-20" showselection="true" selecttype="row" onkeydown="grdList_onkeydown">
          <Formats>
            <Format id="default">
              <Columns>
                <Column size="40"/>
                <Column size="80"/>
                <Column size="80"/>
                <Column size="250"/>
                <Column size="80"/>
                <Column size="80"/>
                <Column size="98"/>
                <Column size="250"/>
              </Columns>
              <Rows>
                <Row size="34" band="head"/>
                <Row size="34"/>
              </Rows>
              <Band id="head">
                <Cell displaytype="checkboxcontrol" edittype="checkbox" style="background: ;" checkboxsize="17" background="#f3f7f7"/>
                <Cell col="1" style="background: ;" text="NAME" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
                <Cell col="2" style="background: ;" text="TYPE" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
                <Cell col="3" style="background: ;" text="ADDRESS" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
                <Cell col="4" style="background: ;" text="SET&#13;&#10;AMOUNT" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
                <Cell col="5" style="background: ;" text="CREATE&#13;&#10;DATE" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
                <Cell col="6" style="background: ;" text="CONFIRMED&#13;&#10;AMOUNT" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
                <Cell col="7" text="ETC" expandshow="show" expandimage="URL('imagerc::grd_sort.png')" background="#f3f7f7"/>
              </Band>
              <Band id="body">
                <Cell displaytype="checkboxcontrol" edittype="checkbox" text="bind:chk" checkboxsize="17"/>
                <Cell col="1" text="bind:Column0"/>
                <Cell col="2" text="bind:Column1"/>
                <Cell col="3" style="align:left;" text="bind:Column2" textAlign="left"/>
                <Cell col="4" style="align:right;" text="bind:Column3" textAlign="right" displaytype="maskeditcontrol" maskeditformat="9,999"/>
                <Cell col="5" displaytype="date" text="bind:Column4" calendardateformat="MM-dd-yyyy"/>
                <Cell col="6" style="align:right;" text="bind:Column5" calendardateformat="yyyy-MM-dd" textAlign="right"/>
                <Cell col="7" style="align:left;" text="bind:Column6" textAlign="left" displaytype="normal"/>
              </Band>
            </Format>
          </Formats>
        </Grid>
        <Static id="staLabel" taborder="1" cssclass="sta_WF_box02" left="0" top="143" right="20" height="50" text=""/>
        <Static id="staName" taborder="2" text="Name" cssclass="sta_WF_condition01" left="10" top="153" width="64" height="30"/>
        <Edit id="edtSearch" taborder="3" left="62" top="153" width="128" height="30" autoselect="true" onkeydown="edt_Search_onkeydown" onkeyup="edt_Search_onkeyup"/>
        <Static id="staDate" taborder="4" text="Created Date" cssclass="sta_WF_condition01" left="197" top="153" width="108" height="30"/>
        <Calendar id="calFrom" taborder="5" left="313" top="153" width="120" height="30" dateformat="SHORTDATE" value="20180101" autoselect="true" editformat="SHORTDATE"/>
        <Calendar id="calTo" taborder="6" left="459" top="153" width="120" height="30" dateformat="SHORTDATE" value="20191231" autoselect="true" editformat="SHORTDATE"/>
        <Static id="Static05" taborder="7" text="~" left="438" top="153" width="16" height="30" textAlign="center"/>
        <Static id="staInfo" taborder="8" text="You can check the functions mainly used in the grid component. Right-click in the header and body area.&#13;&#10;-Sort, multi-sort, column hide, filter&#13;&#10;-Excel export / import, frame fixation (Column / Row), scroll type, personalization function (format storage)&#13;&#10;&#13;&#10;※ In the case of the scroll type, the function is activated when changing the setting value in the menu and scrolling with the Grid scroll TrackBar." wordwrap="char" cssclass="sta_WF_box03" left="0" top="0" right="20" height="130"/>
        <Static id="stcSelectType" taborder="9" text="Select Type" cssclass="sta_WF_condition01" left="587" top="153" width="88" height="30"/>
        <Radio id="rdoSelectType" taborder="10" left="683" top="148" width="254" height="40" innerdataset="innerdataset" codecolumn="codecolumn" datacolumn="datacolumn" direction="vertical" rowcount="2" onitemchanged="fnCommChange" value="row" text="row" index="0">
          <Dataset id="innerdataset">
            <ColumnInfo>
              <Column id="codecolumn" size="256"/>
              <Column id="datacolumn" size="256"/>
            </ColumnInfo>
            <Rows>
              <Row>
                <Col id="codecolumn">row</Col>
                <Col id="datacolumn">Row</Col>
              </Row>
              <Row>
                <Col id="codecolumn">multirow</Col>
                <Col id="datacolumn">Multirow</Col>
              </Row>
              <Row>
                <Col id="codecolumn">area</Col>
                <Col id="datacolumn">Area</Col>
              </Row>
              <Row>
                <Col id="codecolumn">multiarea</Col>
                <Col id="datacolumn">Multiarea</Col>
              </Row>
              <Row>
                <Col id="codecolumn">cell</Col>
                <Col id="datacolumn">Cell</Col>
              </Row>
            </Rows>
          </Dataset>
        </Radio>
      </Layout>
      <Layout name="mobile" screenid="mobile" width="480" height="768" mobileorientation="portrait">
        <Static id="staInfo" right="10" left="10" top="50" height="96"/>
        <Grid id="grdList" left="10" top="250" right="10" bottom="10"/>
        <Static id="staLabel" left="10" top="166" height="74" right="10"/>
        <Static id="staDate" left="29" top="206" width="80" height="24"/>
        <Calendar id="calFrom" left="108" top="206" width="105" height="24"/>
        <Calendar id="calTo" left="229" top="206" width="105" height="24"/>
        <Static id="Static05" left="217" top="206" width="10" height="24"/>
        <Radio id="rdoSelectType" left="683" top="148" width="254" height="40"/>
      </Layout>
    </Layouts>
    <Objects>
      <Dataset id="dsList" firefirstcount="0" firenextcount="0" useclientlayout="false" updatecontrol="true" enableevent="true" loadkeymode="keep" loadfiltermode="keep" reversesubsum="false">
        <ColumnInfo>
          <Column id="chk" type="STRING" size="256"/>
          <Column id="Column0" type="STRING" size="256"/>
          <Column id="Column1" type="STRING" size="256"/>
          <Column id="Column2" type="STRING" size="256"/>
          <Column id="Column3" type="BIGDECIMAL" size="256"/>
          <Column id="Column4" type="STRING" size="256"/>
          <Column id="Column5" type="BIGDECIMAL" size="256"/>
          <Column id="Column6" type="STRING" size="256"/>
        </ColumnInfo>
        <Rows>
          <Row>
            <Col id="Column3">321458</Col>
            <Col id="Column4">20170101</Col>
            <Col id="Column5">321458</Col>
            <Col id="Column0">William Penn</Col>
            <Col id="Column2">Pennsylvania, USA</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column6">William Penn was the founder of the English North American colony, the Province of Pennsylvania.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">425862</Col>
            <Col id="Column4">20170201</Col>
            <Col id="Column5">425862</Col>
            <Col id="Column0">Benjamin Franklin</Col>
            <Col id="Column2">Milk Street, Boston, Massachusetts, USA</Col>
            <Col id="Column1">input</Col>
            <Col id="Column6">Benjamin Franklin was an American polymath and one of the founding fathers of the USA.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">57786</Col>
            <Col id="Column4">20170601</Col>
            <Col id="Column5">57786</Col>
            <Col id="Column0">George Washington</Col>
            <Col id="Column2">Popes Creek, Westmoreland County, Virgina USA</Col>
            <Col id="Column1">modify</Col>
            <Col id="Column6">George Washington was an American political leader, amry general and one  of the founding fathers of the USA.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">51651</Col>
            <Col id="Column4">20170931</Col>
            <Col id="Column5">51651</Col>
            <Col id="Column0">Thomas Paine</Col>
            <Col id="Column2">Thetford, United Kingdom</Col>
            <Col id="Column1">delete</Col>
            <Col id="Column6">Was an influential thinker, writer and a key figure in radicalism. He later moved to the USA.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">216548</Col>
            <Col id="Column4">20171005</Col>
            <Col id="Column5">216548</Col>
            <Col id="Column0">Thomas Jefferson</Col>
            <Col id="Column2">Shadwell, Virginia, USA</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column6">Founding Father and the principal author of the Declaration of Independence</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">216218</Col>
            <Col id="Column4">20171111</Col>
            <Col id="Column5">216218</Col>
            <Col id="Column0">Alexander Hamilton</Col>
            <Col id="Column2">Charlestown, Saint Kitts and Newis</Col>
            <Col id="Column1">input</Col>
            <Col id="Column6">Founding Father who served as a soldier, economist and lawyer.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">954561</Col>
            <Col id="Column4">20170101</Col>
            <Col id="Column5">954561</Col>
            <Col id="Column0">John Adams</Col>
            <Col id="Column2">Braintree, Massachusetts USA</Col>
            <Col id="Column1">modify</Col>
            <Col id="Column6">Founding Father and the second US President.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">2121684</Col>
            <Col id="Column4">20170201</Col>
            <Col id="Column5">2121684</Col>
            <Col id="Column0">James Madison</Col>
            <Col id="Column2">Belle Grove</Col>
            <Col id="Column1">delete</Col>
            <Col id="Column6">The fourth President of the USA and drafted the Constitution and the Bill of Rights.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">6549845</Col>
            <Col id="Column4">20170601</Col>
            <Col id="Column5">6549845</Col>
            <Col id="Column0">John Marshall</Col>
            <Col id="Column2">Germantown Road, Midland, Virginia USA</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column6">Influential fourth Chief of Justice of the United States.</Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="Column3">65150</Col>
            <Col id="Column4">20170931</Col>
            <Col id="Column5">65150</Col>
            <Col id="Column0">Abigail Adams</Col>
            <Col id="Column2">180 Norton St, Weymouth, Massachusetts USA</Col>
            <Col id="Column1">input</Col>
            <Col id="Column6">Wife and confidant of John Adams. </Col>
            <Col id="chk"/>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Sojourner Truth</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column2">Rifton, New York USA</Col>
            <Col id="Column3">158886</Col>
            <Col id="Column4">20170429</Col>
            <Col id="Column5">158886</Col>
            <Col id="Column6">African-American abolitionist and women’s rights campaigner. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Abraham Lincoln</Col>
            <Col id="Column1">input</Col>
            <Col id="Column2">Licoln Farm Rd, Hodgenville, Kentucky USA</Col>
            <Col id="Column3">258624</Col>
            <Col id="Column4">20170111</Col>
            <Col id="Column5">258624</Col>
            <Col id="Column6">16th President of the US from 1861-1865. He led the Union forces during the American civil war. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Harriet Tubman</Col>
            <Col id="Column1">modify</Col>
            <Col id="Column2">Dorchester County, Maryland USA</Col>
            <Col id="Column3">4569985</Col>
            <Col id="Column4">20170829</Col>
            <Col id="Column5">4569985</Col>
            <Col id="Column6">Tubman escaped from slavery but returned on many dangerous missions to Maryland where she helped lead slaves to freedom. She also served as agent and leader during the Civil War. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Emily Dickinson</Col>
            <Col id="Column1">delete</Col>
            <Col id="Column2">Amherst, Massachusetts USA</Col>
            <Col id="Column3">1245568</Col>
            <Col id="Column4">20170605</Col>
            <Col id="Column5">1245568</Col>
            <Col id="Column6">One of America’s greatest poets, Emily Dickinson lived most of her life in seclusion. Her poems were published posthumously and received widespread literary praise for their bold and unconventional style.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Andrew Carnegie</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column2">Dunfermline, United Kingdom</Col>
            <Col id="Column3">336985</Col>
            <Col id="Column4">20170614</Col>
            <Col id="Column5">336985</Col>
            <Col id="Column6"> Carnegie became very rich, through his control of the US steel industry and other investments. With his wealth, he became a philanthropist.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">John D. Rockefeller</Col>
            <Col id="Column1">input</Col>
            <Col id="Column2">Richford, New York USA</Col>
            <Col id="Column3">578962</Col>
            <Col id="Column4">20170231</Col>
            <Col id="Column5">578962</Col>
            <Col id="Column6">Rockefeller was a successful businessman who controlled much of the US oil and railroad industries. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Thomas Edison</Col>
            <Col id="Column1">modify</Col>
            <Col id="Column2">Edison Dr, Milan, Ohio USA</Col>
            <Col id="Column3">11235</Col>
            <Col id="Column4">20170723</Col>
            <Col id="Column5">11235</Col>
            <Col id="Column6">Pioneer of the mass use and distribution of electricity. Edison was one of the most prolific inventors, who developed commercially available electric light bulbs.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Woodrow Wilson</Col>
            <Col id="Column1">delete</Col>
            <Col id="Column2">Staunton, Virginia USA</Col>
            <Col id="Column3">569875</Col>
            <Col id="Column4">20170406</Col>
            <Col id="Column5">569875</Col>
            <Col id="Column6">US president. Wilson was President during the First World War. His idealistic 14 points formed the basis for the League of Nations, the forerunner of the United Nations.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Booker T. Washington</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column2">Hale's Ford, Westlake Corner, Virginia USA</Col>
            <Col id="Column3">5588966</Col>
            <Col id="Column4">20170308</Col>
            <Col id="Column5">5588966</Col>
            <Col id="Column6">Author and orator, Washington was an adviser to the presidents of Roosevelt and Taft. He was the de facto leader of African-Americans. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Theodore Roosevelt</Col>
            <Col id="Column1">input</Col>
            <Col id="Column2">28 East 20th Street, Manhattan, New York USA</Col>
            <Col id="Column3">639996</Col>
            <Col id="Column4">20171205</Col>
            <Col id="Column5">639996</Col>
            <Col id="Column6">President (1901-09) Roosevelt was a leading political figure of the Progressive Era – fighting corruption and the power of monopoly trusts. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Ida B. Wells</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column2">Holly Springs, Mississippi USA</Col>
            <Col id="Column3">859648</Col>
            <Col id="Column4">20170925</Col>
            <Col id="Column5">859648</Col>
            <Col id="Column6">African-American activist for both civil rights and women’s suffrage.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Henry Ford</Col>
            <Col id="Column1">input</Col>
            <Col id="Column2">Greenfield Township, Michighan USA</Col>
            <Col id="Column3">15698</Col>
            <Col id="Column4">20170722</Col>
            <Col id="Column5">15698</Col>
            <Col id="Column6">Founder of Ford motor company. Ford pioneered the use of the assembly line for making cars, helping to reduce the price and make cars affordable for the average American consumer.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">W.E.B Du Bois</Col>
            <Col id="Column1">modify</Col>
            <Col id="Column2">Great Barrington, Massachusetts USA</Col>
            <Col id="Column3">75489</Col>
            <Col id="Column4">20170614</Col>
            <Col id="Column5">75489</Col>
            <Col id="Column6">Du Bois was an influential African-American activist who sought to campaign for full equality between blacks and whites. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Wright Brothers</Col>
            <Col id="Column1">delete</Col>
            <Col id="Column2">Millville, Indiana and Dayton, Ohio</Col>
            <Col id="Column3">63963</Col>
            <Col id="Column4">20170416</Col>
            <Col id="Column5">63963</Col>
            <Col id="Column6">Pioneers of developing the first powered airplanes.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Herbert Hoover</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column2">West Branch, Iowa, USA</Col>
            <Col id="Column3">668955</Col>
            <Col id="Column4">20170814</Col>
            <Col id="Column5">668955</Col>
            <Col id="Column6">Herbert Hoover was the 31st President of the Unites States. He served during the Great Depression.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Margaret Sanger</Col>
            <Col id="Column1">input</Col>
            <Col id="Column2">Corning, New York, USA</Col>
            <Col id="Column3">754896</Col>
            <Col id="Column4">20170517</Col>
            <Col id="Column5">754896</Col>
            <Col id="Column6">Margaret Sanger was a leading pioneer in providing contraception and health care services to women. </Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Franklin D. Roosevelt</Col>
            <Col id="Column1">modify</Col>
            <Col id="Column2">Hyde Park, New York, USA</Col>
            <Col id="Column3">1258963</Col>
            <Col id="Column4">20170318</Col>
            <Col id="Column5">1258963</Col>
            <Col id="Column6">Franklin D. Roosevelt was the 32nd President of the United States. He served throught he Great Depression and the Second World War.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Babe Ruth</Col>
            <Col id="Column1">delete</Col>
            <Col id="Column2">Baltimore, Marlyand, USA</Col>
            <Col id="Column3">458962</Col>
            <Col id="Column4">20170704</Col>
            <Col id="Column5">458962</Col>
            <Col id="Column6">A great baseball player who contributed to the rising popularity of the sport in 1920s and early 1930s.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Amelia Earhart</Col>
            <Col id="Column1">inquiry</Col>
            <Col id="Column2">Atchinson, Kansas, USA</Col>
            <Col id="Column3">15756</Col>
            <Col id="Column4">20170114</Col>
            <Col id="Column5">15756</Col>
            <Col id="Column6">She was an aviation pioneer and the first woman to fly across the Atlantic.</Col>
          </Row>
          <Row>
            <Col id="chk"/>
            <Col id="Column0">Ernest Hemingway</Col>
            <Col id="Column1">input</Col>
            <Col id="Column2">Oak Park, Illinois, USA</Col>
            <Col id="Column3">25896</Col>
            <Col id="Column4">20170326</Col>
            <Col id="Column5">25896</Col>
            <Col id="Column6">An American author and journalist who produced many famous works, including "For Whom the Bell Tolls".</Col>
          </Row>
        </Rows>
      </Dataset>
      <Dataset id="dsGridPopupMenu">
        <ColumnInfo>
          <Column id="id" type="STRING" size="256"/>
          <Column id="level" type="STRING" size="256"/>
          <Column id="caption" type="STRING" size="256"/>
          <Column id="icon" type="STRING" size="256"/>
          <Column id="enable" type="STRING" size="256"/>
          <Column id="type" type="STRING" size="256"/>
        </ColumnInfo>
        <Rows>
          <Row>
            <Col id="id">chkAll</Col>
            <Col id="level">0</Col>
            <Col id="caption">Select All</Col>
            <Col id="enable">true</Col>
            <Col id="type">chk</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">chkClear</Col>
            <Col id="level">0</Col>
            <Col id="caption">Cancel selection</Col>
            <Col id="enable">true</Col>
            <Col id="type">chk</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">hide</Col>
            <Col id="level">0</Col>
            <Col id="caption">Hide</Col>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">unhide</Col>
            <Col id="level">0</Col>
            <Col id="caption">Unhide</Col>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">unhideAll</Col>
            <Col id="level">0</Col>
            <Col id="caption">Unhide All</Col>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">none</Col>
            <Col id="level">0</Col>
            <Col id="caption">--------------------------</Col>
            <Col id="icon"/>
            <Col id="enable">false</Col>
            <Col id="type">head</Col>
          </Row>
          <Row>
            <Col id="id">asc</Col>
            <Col id="level">0</Col>
            <Col id="caption">Ascending</Col>
            <Col id="icon"/>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
          </Row>
          <Row>
            <Col id="id">desc</Col>
            <Col id="level">0</Col>
            <Col id="caption">Descending</Col>
            <Col id="icon"/>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
          </Row>
          <Row>
            <Col id="id">clear</Col>
            <Col id="level">0</Col>
            <Col id="caption">Cancel Sort</Col>
            <Col id="enable">false</Col>
            <Col id="type">head</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">multiSort</Col>
            <Col id="level">0</Col>
            <Col id="caption">Multiple sort</Col>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">multiSortClear</Col>
            <Col id="level">0</Col>
            <Col id="caption">Cancel Multiple Sort</Col>
            <Col id="enable">true</Col>
            <Col id="type">head</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">filter</Col>
            <Col id="level">0</Col>
            <Col id="caption">Add filter</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">filterClear</Col>
            <Col id="level">0</Col>
            <Col id="caption">Remove filter</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">none</Col>
            <Col id="level">0</Col>
            <Col id="caption">--------------------------</Col>
            <Col id="enable">false</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">EXCEL</Col>
            <Col id="level">0</Col>
            <Col id="caption">EXCEL</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">export</Col>
            <Col id="level">1</Col>
            <Col id="caption">Export</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">import</Col>
            <Col id="level">1</Col>
            <Col id="caption">Import</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">none</Col>
            <Col id="level">0</Col>
            <Col id="caption">--------------------------</Col>
            <Col id="icon"/>
            <Col id="enable">false</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">FIX</Col>
            <Col id="level">0</Col>
            <Col id="caption">Freame fixation</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">shapeFix</Col>
            <Col id="level">1</Col>
            <Col id="caption">Fixed column</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">shapeFree</Col>
            <Col id="level">1</Col>
            <Col id="caption">Cancel fixed column</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">rowFix</Col>
            <Col id="level">1</Col>
            <Col id="caption">Fixed row</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">rowFree</Col>
            <Col id="level">1</Col>
            <Col id="caption">Cancel Fixed row</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">fastvscrolltype</Col>
            <Col id="level">0</Col>
            <Col id="caption">Scroll Options</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">default</Col>
            <Col id="level">1</Col>
            <Col id="caption">default</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">topdisplay</Col>
            <Col id="level">1</Col>
            <Col id="caption">Display top</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">centerdisplay</Col>
            <Col id="level">1</Col>
            <Col id="caption">Display center</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">topbottomdisplay</Col>
            <Col id="level">1</Col>
            <Col id="caption">Display top and bottom</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">topcenterbottomdisplay</Col>
            <Col id="level">1</Col>
            <Col id="caption">Display top, center, bottom</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">trackbarfollow</Col>
            <Col id="level">1</Col>
            <Col id="caption">Display row position</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
          </Row>
          <Row>
            <Col id="id">gridFormat</Col>
            <Col id="caption">Save settings</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="level">0</Col>
            <Col id="icon"/>
          </Row>
          <Row>
            <Col id="id">gridFormatOrg</Col>
            <Col id="caption">Default</Col>
            <Col id="enable">true</Col>
            <Col id="type">body</Col>
            <Col id="level">0</Col>
            <Col id="icon"/>
          </Row>
        </Rows>
      </Dataset>
    </Objects>
    <Script type="xscript5.1"><![CDATA[/**
*  nexacro 17 demo
*  @MenuPath    grid > Functions
*  @FileName  Functions.xfdl 
*  @Creator  presales
*  @CreateDate  2019.10.14
*  @Desction    Define script standards and annotation standards
************** Source modification history ************************************
*  date            Modifier                Description
*******************************************************************************
*  2019.10.14      presales                  최초 생성 
*******************************************************************************
*/

/******************************************************************************
* FORM Variable declaration area
********************************************************************************/
// Sorting indicator classification (text or image)
this.MARKER_TYPE = "image";

// Grid Head - The path of the marker text or image  
// [Display in ascending order, display in descending order]
this.MARKER = ["url('imagerc::grd_sort_up.png')", "url('imagerc::grd_sort_dn.png')", "url('imagerc::grd_sort.png')"];	//["▲", "▼"];

this.varFlag = "";
this.colIdx1 = "";

// Filter image 
this.FILTER_ENABLE_IMAGE_URL = "imagerc::grd_filter_combo.png";
//this.FILTER_ENABLE_IMAGE_URL = "img::img_TreeClose.png";
this.FILTER_ENABLE_IMAGE_SIZE = [30, 30];

// Filter Apply image
this.FILTER_APPLY_IMAGE_URL = "imagerc::grd_filter_check.png";
this.FILTER_APPLY_IMAGE_SIZE = [30, 30];

// Message to display when no results are found
this.GRID_FIND_NO_RESULT_MESSAGE = "\"{0}\" 을(를) 더 이상 찾을 수 없습니다.";

// Message to display the number of changes when replacing all
this.GRID_REPLACE_COUNT_MESSAGE = "{0}개 항목이 변경되었습니다.";

this.nCell1 = "";
this.cellFixFalg = "off";

/*  
Grid support String Mask text

@ : All Ascii Text (not multilingual, such as Korean)
# : Any decimal number (0-9)   
* : Any alphabetic character (a-zA-Z)
9 : All alphabets and numbers (a-zA-Z0-9)
A : Uppercase alphabets (A-Z)
a : Lowercase alphabets (a-z)
Z : Uppercase alphabet, numbers (A-Z0-9)
z : Lowercase alphabet, numbers (a-z0-9)
*/

this._stringMaskChar = {
    "@": /[\x20-\x7D]/, // /[\u0020-\u00ff]/,
    "#": /[0-9]/,
    "*": /[a-zA-Z]/,
    "9": /[a-zA-Z0-9]/,
    "A": /[A-Z]/,
    "a": /[a-z]/,
    "Z": /[A-Z0-9]/,
    "z": /[a-z0-9]/
};

this._chkEmpty = String.fromCharCode(0x08);

/************************************************************************************************
* FORM EVENT Domain(onload, onbeforeclose)
************************************************************************************************/

/**
* @description Form onload
*/
this.Functions_onload = function(obj: Form, e: nexacro.LoadEventInfo)
{
    this.setTimer(1, 10);
	this.fn_setCPGrid(this.grdList);//copy & paste
}

/************************************************************************************************
* CALLBACK Callback processing part (Transaction, Popup)
************************************************************************************************/

/************************************************************************************************
* CRUD and TRANSACTION service call handling
************************************************************************************************/

/************************************************************************************************
* User FUNCTION domain
************************************************************************************************/

/************************************************************************************************
 * Function Name: fnCommChange
 * Description  : Grid SelectType change
 * Arguments    : 
 * Return       : 
*************************************************************************************************/
this.fnCommChange = function(obj:nexacro.Radio,e:nexacro.ItemChangeEventInfo)
{
	this.grdList.set_selecttype(e.postvalue);
};

/************************************************************************************************
 * Function Name: fnIsUndefined
 * Description  : return True if value is undefined
 * Arguments    : @param {*} value 		
 * Return       : @return {boolean} whether value is undefined 
*************************************************************************************************/
this.fnIsUndefined = function(value)
{
	return value === undefined;
};

/************************************************************************************************
 * Function Name: fnIndexOf
 * Description  : Returns the array position where the specified item first appears. 
 * Arguments    : @param {array} array: Array to be searched.
		 		  @param {object} item: Item to search for.
				  @param {number=} from: Index of array to start search from (default: 0).
				  @param {boolean=} strict: True - Comparison without casting ('==='), 
									False - Comparison after casting ('==') (default: False).
 * Return       : @return {number} Index of found item in the Array. Returns -1 if not found.
*************************************************************************************************/
this.fnIndexOf = function(array, item, from, strict)
{
	var len = array.length;
	
	if (from == null)
		from = 0;
		
	strict == !!strict;
	
	from = (from < 0) ? Math.ceil(from) : Math.floor(from);
	
	if (from < 0)
	{
		from += len;
	}
	
	if (strict)
	{
		for (; from < len; from++) 
		{
			if ( array[from] === item)
			{
				return from;
			}
		}
	}
	else
	{
		for (; from < len; from++) 
		{
			if ( array[from] == item)
			{
				return from;
			}
		}
	}
	
	return -1;
};

/************************************************************************************************
 * Function Name: fnIndexOfIgnoreCase
 * Description  : Search for the position of a string without case sensitivity.
 * Arguments    : @param {string} value: Target string (example: "aaBBbbcc")
		  		  @param {string} sFind: String to find (example: "bb")
		          @param {number} nStart: Index of target string where to start search 
											(Default=0) (example: 1 ) 
 * Return       : @return {number} Start index position of the found string (example: 2). 
								   In case of failure = -1.
*************************************************************************************************/
this.fnIndexOfIgnoreCase = function(value, sFind, nStart)
{
	return value.toLowerCase().indexOf(sFind.toLowerCase(), nStart);
};

/************************************************************************************************
 * Function Name: fnReplaceIgnoreCase
 * Description  : Substitutes a given string, ignoring the case.
 * Arguments    : @param {string} sOrg 대상 문자열( 예 : "aaBBbbcc" )
		  		  @param {string} sRepFrom 찾을 문자열( 예 : "bb" )
		  		  @param {string} sRepTo 치환할 문자열 ( 예 : "xx" )
 * Return       : @return {string} 치환된 문자열 ( 예 : "aaxxxxccxx" ).
*************************************************************************************************/
this.fnReplaceIgnoreCase = function(sOrg, sRepFrom, sRepTo)
{
	var pos, nStart=0, sRet="";
		
	while(1)
	{
		pos = this.fnIndexOfIgnoreCase(sOrg, sRepFrom, nStart);
		if( pos < 0 )
		{
			sRet += sOrg.substr( nStart );
			break;
		}
		else
		{
			sRet += sOrg.substr( nStart, pos - nStart);
			sRet += sRepTo;
			nStart = pos+sRepFrom.length;
		}
	}	
};

/************************************************************************************************
 * Function Name: fnGetCurrentScrollBarSize
 * Description  : Scroll bar size is returned only when the scroll bar is displayed.
 * Arguments    :  @param {XComp} XComp nexacro Component
		  		   @param {string} type Scroll bar type (horizontal scroll bar: "horz", vertical scroll bar: "vert")
		  		 
 * Return       :  @return {number} Scrollbar size (0 if no scrollbar is present or displayed).
*************************************************************************************************/
this.fnGetCurrentScrollBarSize = function(XComp, type)
{
	if(XComp instanceof nexacro.Div)
	{
		XComp = XComp.form;
	}
	var scrollBar = (type == "horz") ? XComp.hscrollbar : XComp.vscrollbar;
	
	return (scrollBar && scrollBar.visible ? (type == "horz" ? scrollBar.getOffsetHeight() : scrollBar.getOffsetWidth()) : 0);
};

/************************************************************************************************
 * Function Name: fnGetBorderWidth
 * Description  : Returns border width(px) of nexacro component  
 * Arguments    : @param {XComp} xComp nexacro Component
		 		  
 * Return       : @return {array.<number>} [ leftWdith, topWdith, rightWdith, bottomWdith ]
*************************************************************************************************/
this.fnGetBorderWidth = function(xComp)
{
	var border = xComp._getCurrentStyleBorder();
	var leftWidth = 0,topWidth = 0,rightWidth = 0,bottomWidth = 0;
	
	if (border)
	{
		leftWidth   = border.left.width;
		topWidth    = border.top.width;
		rightWidth  = border.right.width;
		bottomWidth = border.bottom.width;
		
		leftWidth   = nexacro.toNumber(leftWidth.replace("px",""), 0);
		topWidth    = nexacro.toNumber(topWidth.replace("px",""), 0);
		rightWidth  = nexacro.toNumber(rightWidth.replace("px",""), 0);
		bottomWidth = nexacro.toNumber(bottomWidth.replace("px",""), 0);
		
		return [leftWidth, topWidth, rightWidth, bottomWidth];
	}

	return [0, 0, 0, 0];
};

/************************************************************************************************
 * Function Name: fnLookup
 * Description  : Returns the component or object that first matches the name specified as the 
				  upper range including the component to start the search.
 * Arguments    : @param {XComp} p Start search component.
				  @param {string} name Name of component or object to search for.
 * Return       : @return {XComp|object} Return found component or object.
*************************************************************************************************/
this.fnLookup = function(p, name)
{
	var o;
	
	while (p)
	{		
		o = p.components;
		if ( o && o[name] ) return o[name];
		
		o = p.objects;
		if ( o && o[name] ) return o[name];
		
		p = p.parent;
	}
	return null;
};

/************************************************************************************************
 * Function Name: fnIsNumber
 * Description  : Returns whether value is number.
 * Arguments    : @param {*} value: the value to be identified whether is a number.
 * Return       : @return {boolean} True or False corresponding to whether value is number or not.
*************************************************************************************************/
this.fnIsNumber = function(value)
{
	return typeof value === 'number' && isFinite(value);
};

/************************************************************************************************
 * Function Name: fnIsDate
 * Description  : Returns whether value is a Date.
 * Arguments    : @param {date} value Value to check.
 * Return       : @return {boolean} True or False - whether value is a Date or not.
*************************************************************************************************/
this.fnIsDate = function(value)
{
	var str = Object.prototype.toString;
	return str.call( value ) === '[object Date]';
};

/************************************************************************************************
 * Function Name: fnGetLastDayOfMonth
 * Description  : Find the last day of the month as a number.
 * Arguments    : @param {number | string} value 'yyyyMMdd' Date of form.
 * Return       : @return {number} Last date numeric value.
*************************************************************************************************/
this.fnGetLastDayOfMonth = function(value)
{
	var nMonth, nLastDate;

	if ( this.fnIsDate(value) )
	{
		nMonth = value.getMonth() + 1;
	}
	else
	{
		nMonth = parseInt(value.substr(4,2), 10);
	}
	if( nMonth == 1 || nMonth == 3 || nMonth == 5 || nMonth == 7  || nMonth == 8 || nMonth == 10 || nMonth == 12 ) 
	{
		nLastDate = 31;
	} 
	else if( nMonth == 2 ) 
	{
		if( this.fnIsLeapYear(value) == true ) 
		{
			nLastDate = 29;
		} 
		else 
		{
			nLastDate = 28;
		}
	} 
	else 
	{
		nLastDate = 30;
	}
		
	return nLastDate;
};

/************************************************************************************************
 * Function Name: fnIsLeapYear
 * Description  : Whether it is a leap year.
 * Arguments    : @param {string|number|date|nexacro.Date} value yyyyMMdd Date of type (string).<br>
		           number In the case of type yyyy.<br>
		           JavaScript Date.<br>
		           DatasetThe column value whose column type is DATE.
 * Return       : @return {boolean} Whether it is a leap year (false if not entered).
*************************************************************************************************/
this.fnIsLeapYear = function(value)
{
	var result;
	var year;
	
	if( this.fnIsEmpty(value) ) {
		return false;
		
	} else if ( this.fnIsString(value) ) {
		year = parseInt(value.substring(0,4), 10);
	
	} else if ( this.fnIsNumber(value) ) {
		year = value;
	
	} //Processed when the column type of dataset is DATE.
	else if(value instanceof nexacro.Date) {
		value = value.toString();
		
		if(this.fnIsEmpty(value)) {
			return false;
		}
		
		year = parseInt(value.substring(0,4), 10);
		
	} else if( this.fnIsDate(value) ) {
		
		year = value.getFullYear();
	}

	
	if ((year % 4) == 0) 
	{
		if ((year % 100) != 0 || (year % 400) == 0){
			result = true;
		} 
		else 
		{
			result = false;
		}
	} 
	else 
	{
		result = false;
	}
	
	return result;
};

/************************************************************************************************
 * Function Name: fnIsEmpty
 * Description  : Null value check
 * Arguments    : @param value To check value
 * Return       : @return {boolean} true/false
*************************************************************************************************/
this.fnIsEmpty = function(value)
{
	// null, undefined ==> true
	if ( value == null ) return true;
	
	// String, Array ==> length == 0
	if ( this.fnIsString(value) || this.fnIsArray(value) )
	{
		return value.length == 0 ? true : false;
	}
	else if ( this.fnIsObject(value) )
	{
		for (var p in value) 
		{
			if ( value.hasOwnProperty(p) )
			{
				return false;
			}
		}
		return true;
	}		
};

/************************************************************************************************
 * Function Name: fnIsString
 * Description  : Returns whether value is a string
 * Arguments    : @param {*} value identify value
 * Return       : @return {boolean} True or False - Whether a string .
*************************************************************************************************/
this.fnIsString = function(value)
{
	return typeof value === 'string';
};

/************************************************************************************************
 * Function Name: fnIsNumber
 * Description  : Returns whether value is number
 * Arguments    : @param {*} value Value to check.
 * Return       : @return {boolean} Whether number.
*************************************************************************************************/
this.fnIsNumber = function(value)
{
	 return typeof value === 'number' && isFinite(value);
};

/************************************************************************************************
 * Function Name: fnIsObject
 * Description  : Returns whether value is number
 * Arguments    : @param {*} value Value to check.
 * Return       : @return {boolean} Object or not.
*************************************************************************************************/
this.fnIsObject = function(value)
{
	if ( value === null || value === undefined ) return false;
			
	// nexacro Component
	if ( this.fnIsXComponent(value) ) return false;
	
	// nexacro Object (e.g. Dataset)
	if( value instanceof nexacro.Object ) return false;
	
	return typeof value == "object" && 
		   'constructor' in value &&
		   value.constructor === Object;
};

/************************************************************************************************
 * Function Name: fnIsArray
 * Description  : Returns whether value is an Array
 * Arguments    : @param {*} value Value to check
 * Return       : @return {boolean} Array or not
*************************************************************************************************/
this.fnIsArray = function(value)
{
	var str = Object.prototype.toString;
	return str.call( value ) === '[object Array]';
};
		
/************************************************************************************************
 * Function Name: fnIsXComponent
 * Description  : Returns whether the value is a nexacro component
 * Arguments    : @param {*} value Value to check
 * Return       : @return {boolean} Whether nexacro component
*************************************************************************************************/
this.fnIsXComponent = function(value)
{
	if ( value === null || value === undefined  ) return false;
	return value instanceof nexacro.Component;
};
		
/**
* Grid Initial Settings
* @param {Grid} obj Target Grid Component
*/
this.fnSetGrid = function(obj)
{
    obj.orgFormat = obj.getCurFormatString();
	
    this.fnGetGridFormat(obj);
	
    // Initialization to use the grid head cell click alignment function
    obj.addEventHandler("onheadclick", this.gridonheadclick, this);
	
    // Specify whether replaceable property
    obj.replaceable = true;
    obj.hidelist = "";
	
    var form = obj.parent;
    var ds = form.gridSortRClickDataset; // Dataset reference
    var pmnu = form.gridSortRClickPopupMenu; // Pop-up menu component reference
	
    // add oncellclick handler
    obj.addEventHandler("oncellclick", this.gridFindReplaceOnCellClickHandler, this);
	
    ds = this.dsGridPopupMenu;
	
    form.gridSortRClickDataset = this.dsGridPopupMenu;
	
    if (this.gfnIsNull(pmnu))
    {
        // add popupmenu component
        var name = this.gfnGetUniqueId("pmnu_");
		
        pmnu = new PopupMenu();
        pmnu.init(name, 0, 0, 68, 65);
        form.addChild(pmnu.name, pmnu);
        pmnu.set_innerdataset(ds);
        pmnu.set_idcolumn("id");
        pmnu.set_levelcolumn("level");
        pmnu.set_captioncolumn("caption");
        pmnu.set_iconcolumn("icon");
        pmnu.set_enablecolumn("enable");
		pmnu.set_cssclass("pm_basic01");
        pmnu.addEventHandler("onmenuclick", this.sortPopupMenuOnMenuClickHandler, this);
        pmnu.show();
        pmnu.grid = obj;
        form.gridSortRClickPopupMenu = pmnu;
    }
	
    // Added to refer to popup menu in grid event
    obj.rClickPopupMenu = pmnu;
	
    // add onrbuttondown handler
    obj.addEventHandler("onrbuttondown", this.sortGridOnRButtonDownHandler, this);
	
    // Adding filer function to the grid head Initialization
	this.initGridHeadAppendFilter(obj);
	
	this.setPopDiv(obj);
}

/**
* Grid pop-up settings
* @param {Grid} grid Target Grid Component
*/
this.setPopDiv = function(grid)
{
	//this.initGridFindReplace(this.Grid00, true);
	var pdiv = new PopupDiv();
	var name = this.gfnGetUniqueId("pdiv_");
	pdiv.init(name, 0, 0, 250, 310);
	
	grid.parent.addChild(pdiv.name, pdiv);
	
	pdiv.set_background("#f7f7f7");
	pdiv.set_border("1px solid gray");
	pdiv.addEventHandler("oncloseup", this.sortPdivOnCloseUpHandler, this);
	pdiv.set_url("grid::GridSortPop.xfdl");
	pdiv.show();
	
	// Target grid reference
	pdiv.grid = grid;
	
	// Popup reference
	grid.multiSortPopupDiv = pdiv;
}

/**
* oncloseup Event Handler
* @param {PopupDiv} obj PopupDiv Component where the event occurred
* @param {CloseupEventInfo} e CloseupEventInfo
*/
this.sortPdivOnCloseUpHandler = function(obj, e)
{
    var grid = obj.grid;
    var items = obj.returnvalue;
	
    if (!this.gfnIsNull(items))
    {
        this.clearAllSort(grid);
		
        var item;
        for (var i = 0, len = items.length; i < len; i++)
        {
            item = items[i];
            this.setSortStatus(grid, item.index, true, item.status);
        }
		
        this.executeSort(grid);
    }
}

/**
* Open a multiple sort popup window.
* @param {Grid} grid Target Grid Component
* @param {xPComp=} relativeComp Component based on the relative position (left / bottom) to display the popup window
*/
this.popupMultipleSort = function(grid, relativeComp)
{
	var pdiv = grid.multiSortPopupDiv;
    var cells = [], column, text, index;
    var cellCnt = grid.getCellCount("head");
	
    for (var i = 1; i < cellCnt; i++)
    {
        index = this.getBodyCellIndex(grid, i);
        if (index > -1)
        {
            column = this.getBindColumnNameByIndex(grid, index);
            if (!this.gfnIsNull(column))
            {
                text = grid.getCellText(-1, i);
                cells.push(
					{
						column: column,
						index: i,
						text: text
					});
            }
        }
    }
	
    // Assign sorting information to pop-up windows
    pdiv.form.setSortInfo(grid, cells);
    pdiv.trackPopupByComponent(grid, 400, 60);
}

/******************************************************************************
Unit function required for sorting
******************************************************************************/
/**
* onmenuclick Event Handler
* @param {PopupMenu} obj PopupMenu Component where the event occurred
* @param {MenuClickEventInfo} e MenuClickEventInfo
*/
this.sortPopupMenuOnMenuClickHandler = function(obj, e)
{
    var selectId = e.id;
    var cell = obj.headCellIndex;
    var grid = obj.grid;
	
    if (obj.showFilter == true)
    {
        if (selectId != "filterClear")
        {
            grid.set_cellmovingtype("col");
            grid.set_cellsizingtype("col");
            obj.showFilter = false;
            this.hideHeadAppendFilter(grid);
        }
    }
	
    if (selectId == "chkAll")
    {
        this.fnBlockChk(grid);
		
    }
    else if (selectId == "chkClear")
    {
        this.fnBlockUnChk(grid);
		
    }
    else if (selectId == "hide")
    {
        this.fnHide(grid, cell);
    }
    else if (selectId == "unhide")
    {
        this.fnHideCancel(grid, cell);
    }
    else if (selectId == "unhideAll")
    {
        this.fnHideCancelAll(grid, cell);
    }
    else if (selectId == "asc" || selectId == "desc")
    {
        if (this.setSortStatus(grid, cell, false, (selectId == "asc" ? 1 : 2)))
        {
            this.executeSort(grid);
        }
    }
    else if (selectId == "clear")
    {
        this.clearSort(grid, cell);
    }
    else if (selectId == "multiSort")
    {
        this.clearAllSort(grid);
        this.popupMultipleSort(grid, obj);
    }
    else if (selectId == "multiSortClear")
    {
        this.clearAllSort(grid);
    }
    else if (selectId == "find")
    {
        this.showGridFindReplace(grid, "find");
    }
    else if (selectId == "replace")
    {
        if (grid.replaceable)
        {
            this.showGridFindReplace(grid, "replace");
        }
    }
    else if (selectId == "filter" || selectId == "filterClear")
    {
        if (obj.showFilter != true)
        {
            grid.set_cellmovingtype("none");
            grid.set_cellsizingtype("none");
			obj.showFilter = true;
            this.showHeadAppendFilter(grid);
        }
        else
        {
            grid.set_cellmovingtype("col");
            grid.set_cellsizingtype("col");
            obj.showFilter = false;
            this.hideHeadAppendFilter(grid);
        }
    }
    else if (selectId == "export")
    {
        this.fnExport(grid);
    }
    else if (selectId == "import")
    {
        this.fnImport(grid);
    }
    else if (selectId == "shapeFix")
    {
        this.fnCellFix(grid, this.colIdx);
    }
    else if (selectId == "shapeFree")
    {
        this.fnCellFree(grid);
    }
    else if (selectId == "rowFix")
    {
        this.fnRowFix(grid, this.rowIdx);
    }
    else if (selectId == "rowFree")
    {
        this.fnRowFree(grid);
    }
	else if (selectId == "default" || selectId == "topdisplay" || selectId == "centerdisplay" || selectId == "topbottomdisplay"
		|| selectId == "topcenterbottomdisplay" || selectId == "trackbarfollow")
	{
		grid.set_fastvscrolltype(selectId);
	}
    else if (selectId == "gridFormat")
    {
        this.fnSetGridFormat(grid);
    }
    else if (selectId == "gridFormatOrg")
    {
        this.fnClearGridFormat(grid);
    }
}

/**
* onrbuttondown Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {MouseEventInfo} e MouseEventInfo
*/
this.sortGridOnRButtonDownHandler = function(obj, e: nexacro.GridMouseEventInfo)
{
    var row = e.row;
    var cell = e.cell;
    this.colIdx = e.cell;
    this.rowIdx = e.row;
    var pmnu = obj.rClickPopupMenu;
    var ds = this.ds_menu;
	
    //head
    if (row == -1 && cell > -1)
    {
        if (obj.getCellProperty("head", e.col, "displaytype") == "checkbox")
        {
            this.dsGridPopupMenu.filter("type == 'chk'");
        }
        else
        {
            this.dsGridPopupMenu.filter("type == 'head'");
			
            var bodyCellIndex = this.getBodyCellIndex(obj, cell);
            if (bodyCellIndex > -1)
            {
                var rect = obj.getCellRect(row, cell);
                var sortStatus = this.getSortStatus(obj, cell);
				
                if (sortStatus == 1)
                {
                    // Descending, cancelable
                    this.dsGridPopupMenu.setColumn(0, "enable", "false");
                    this.dsGridPopupMenu.setColumn(1, "enable", "true");
                    this.dsGridPopupMenu.setColumn(2, "enable", "true");
                }
                else if (sortStatus == 2)
                {
                    // Ascending, cancelable
                    this.dsGridPopupMenu.setColumn(0, "enable", "true");
                    this.dsGridPopupMenu.setColumn(1, "enable", "false");
                    this.dsGridPopupMenu.setColumn(2, "enable", "true");
                }
                else
                {
                    // Available in ascending and descending order
                    this.dsGridPopupMenu.setColumn(0, "enable", "true");
                    this.dsGridPopupMenu.setColumn(1, "enable", "true");
                    this.dsGridPopupMenu.setColumn(2, "enable", "true");
                }
				
                // Add target grid and cell information
                pmnu.grid = obj;
                pmnu.headCellIndex = cell;
            }
        }
    }
    else
    {
        this.dsGridPopupMenu.filter("type == 'body'");
    }
	
    pmnu.trackPopupByComponent(obj, e.canvasx, e.canvasy);
}

/**
* Retrieve the alignment.
* @param {Grid} grid Target Grid Component
* @param {number} headCellIndex head cell index
* @return {number} sort status (-1:N/A, 0: Initial state, 1:Ascending state, 2:Descending state)
*/
this.getSortStatus = function(grid, headCellIndex)
{
    var bodyCellIndex = this.getBodyCellIndex(grid, headCellIndex);
	
    if (bodyCellIndex < 0) return -1;
	
    var columnName = this.getBindColumnNameByIndex(grid, bodyCellIndex);
	
    var cellInfos = grid._cellInfos;
	
    if (cellInfos && cellInfos[columnName])
    {
        return cellInfos[columnName].status;
    }
    return -1;
}

/**
* Specifies the sorting status. (Actual sorting is handled by executeSort.)
* @param {Grid} grid Target Grid Component
* @param {number} headCellIndex head cell index
* @param {boolean=} isMultiple Multiple selection
* @param {number=} sortStatus Forced sorting status (reverse current status when not specified)
* @return {boolean} Status change
*/
this.setSortStatus = function(grid, headCellIndex, isMultiple, sortStatus)
{
    // Cell sorting information
    if (this.gfnIsNull(grid.cellInfos))
    {
        grid.cellInfos = {};
    }
	
    // Sort target column (order important)
    if (this.gfnIsNull(grid.sortItems))
    {
        grid.sortItems = [];
    }
	
    var bodyCellIndex = this.getBodyCellIndex(grid, headCellIndex);
    if (bodyCellIndex < 0) return false;
	
    var columnName = this.getBindColumnNameByIndex(grid, bodyCellIndex);
	
    var cellInfo,
	sortItem,
	cellInfos = grid.cellInfos,
	sortItems = grid.sortItems,
	status;
	
    if (this.gfnIsNull(columnName))
    {
        //trace("Check Grid body cell bind value");
        return false;
    }
    
    if (columnName == "chk")
    {
		return false;
    }
	
    if (this.gfnIsNull(isMultiple)) isMultiple = false;
	
    if (this.gfnIsNull(sortStatus)) sortStatus = -1;
	
    cellInfo = cellInfos[columnName];
	
    if (this.gfnIsNull(cellInfo))
    {
        var headText = grid.getCellText(-1, headCellIndex);
        cellInfo = cellInfos[columnName] = {
            index: headCellIndex,
            status: 0,
            text: headText
        };
    }
    // set sort status
    if (isMultiple)
    {
        status = cellInfo.status;
        if (sortStatus == -1)
        {
            if (status == 0)
            {
                cellInfo.status = 1;
            }
            else if (status == 1)
            {
                cellInfo.status = 2;
            }
            else if (status == 2)
            {
                cellInfo.status = 1;
            }
        }
        else
        {
            cellInfo.status = sortStatus;
        }
    }
    else
    {
        for (var p in cellInfos)
        {
            if (!cellInfos.hasOwnProperty(p)) return;
			
            cellInfo = cellInfos[p];
			
            if (cellInfo.index == headCellIndex)
            {
                status = cellInfo.status;
                if (sortStatus == -1)
                {
                    if (status == 0)
                    {
                        cellInfo.status = 1;
                    }
                    else if (status == 1)
                    {
                        cellInfo.status = 2;
                    }
                    else if (status == 2)
                    {
                        cellInfo.status = 1;
                    }
                }
                else
                {
                    cellInfo.status = sortStatus;
                }
            }
            else
            {
                cellInfo.status = 0;
            }
			
            if (cellInfo.status == 0)
            {
                for (var j = 0, len2 = sortItems.length; j < len2; j++)
                {
                    if (sortItems[j] !== columnName)
                    {
                        sortItems.splice(j, 1);
                        break;
                    }
                }
            }
        }
    }
	
    var hasItem = false;
    for (var i = 0, len = sortItems.length; i < len; i++)
    {
        if (sortItems[i] == columnName)
        {
            hasItem = true;
            break;
        }
    }
    if (!hasItem)
    {
        sortItems.push(columnName);
    }
    return true;
}

/**
* Apply alignment
* @param {Grid} grid Target Grid Component
*/
this.executeSort = function(grid)
{
    var cellInfo,
	sortItem,
	cellInfos = grid.cellInfos,
	sortItems = grid.sortItems,
	columnName,
	headCellIndex,
	status,
	sortString = "";
	
    if (this.gfnIsNull(cellInfos) || this.gfnIsNull(sortItems)) return;
	
    // keystring combination
    for (var i = 0, len = sortItems.length; i < len; i++)
    {
        columnName = sortItems[i];
        status = cellInfos[columnName].status;
		
        if (status > 0)
        {
            sortString += (status == 1 ? "+" : "-") + columnName;
        }
    }
	
    var aaa = grid.getBindCellIndex("body", columnName);
	
    if (this.varFlag == "-" && aaa == this.colIdx1)
    {
        this.varFlag = "";
        this.clearSort(grid, aaa);
        return;
    }
	
    var ds = grid.getBindDataset();
	
    // keystring check
    var curKeyString = ds.keystring;
    var groupKeyString = "";
	
    if (curKeyString.length > 0 && curKeyString.indexOf(",") < 0)
    {
        var sIndex = curKeyString.indexOf("S:");
        var gIndex = curKeyString.indexOf("G:");
		
        if (sIndex > -1)
        {
            groupKeyString = "";
        }
        else
        {
            if (gIndex < 0)
            {
                groupKeyString = "G:" + curKeyString;
            }
            else
            {
                groupKeyString = curKeyString;
            }
        }
    }
    else
    {
        var temps = curKeyString.split(",");
        var temp;
        for (var i = 0, len = temps.length; i < len; i++)
        {
            temp = temps[i];
            if (temp.length > 0 && temp.indexOf("S:") < 0)
            {
                if (temp.indexOf("G:") < 0)
                {
                    groupKeyString = "G:" + temp;
                }
                else
                {
                    groupKeyString = temp;
                }
            }
        }
    }
	
    if (sortString.length > 0)
    {
        var sortKeyString = "S:" + sortString;
		
        if (groupKeyString.length > 0)
        {
            ds.set_keystring(sortKeyString + "," + groupKeyString);
        }
        else
        {
            ds.set_keystring(sortKeyString);
        }
		
        grid.sortKeyString = sortKeyString;
    }
    else
    {
        ds.set_keystring(groupKeyString);
		
        grid.sortKeyString = "";
    }
	
    this.varFlag = ds.keystring.substr(2, 1);
    this.colIdx1 = grid.getBindCellIndex("body", columnName);
	
    // Sort indication
    var index, text, marker, style;
    for (var p in cellInfos)
    {
        if (!cellInfos.hasOwnProperty(p)) return;
		
        cellInfo = cellInfos[p];
        status = cellInfo.status;
        index = cellInfo.index;
        text = cellInfo.text;
		
        marker = this.gfnDecode(status, 1, this.MARKER[0], 2, this.MARKER[1], this.MARKER[2]);
		
        if (this.MARKER_TYPE == "text")
        {
            grid.setCellProperty("head", index, "text", text + marker);
        }
        else if (this.MARKER_TYPE == "image")
        {
            grid.setCellProperty("head", index, "expandimage", marker);
        }
    }
}

/**
* Remove the alignment state corresponding to a given head cell.
* @param {Grid} grid Target Grid Component
* @param {number} headCellIndex head cell index
*/
this.clearSort = function(grid, headCellIndex)
{
    var bodyCellIndex = this.getBodyCellIndex(grid, headCellIndex);
	
    if (bodyCellIndex < 0) return;
	
    var columnName = this.getBindColumnNameByIndex(grid, bodyCellIndex),
	cellInfos = grid.cellInfos,
	sortItems = grid.sortItems;
	
    if (this.gfnIsNull(cellInfos) || this.gfnIsNull(sortItems)) return;
	
    if (this.gfnIsNull(columnName) || this.gfnIsNull(cellInfos[columnName])) return;
	
    // Change the sorting status
    cellInfos[columnName].status = 0;
	
    // Sort execution
    this.executeSort(grid);
	
    // Remove column information
    for (var i = 0, len = sortItems.length; i < len; i++)
    {
        if (sortItems[i] == columnName)
        {
            sortItems.splice(i, 1);
            break;
        }
    }
	
    // Cell information removal
    delete cellInfos[columnName];
}

/**
* Removes all currently applied alignments.
* @param {Grid} grid Target Grid Component
*/
this.clearAllSort = function(grid)
{
    var cellInfos = grid.cellInfos;
    var sortItems = grid.sortItems;
	
    if (this.gfnIsNull(cellInfos) || this.gfnIsNull(sortItems)) return;
	
    // Returns all sorts to their original state.
    for (var p in cellInfos)
    {
        if (!cellInfos.hasOwnProperty(p)) return;
        cellInfos[p].status = 0;
    }
	
    // Sort execution
    this.executeSort(grid);
	
    // Information initialization
    grid.cellInfos = {};
    grid.sortItems = [];
}

/******************************************************************************
utility function
******************************************************************************/

/**
* Retrieves the column name bound by the body cell index.
* @param {Grid} grid Target Grid Component
* @param {number} index body cell index
*/
this.getBindColumnNameByIndex = function(grid, index)
{	
    var text = "";
    var columnid = "";
    var subCell = grid.getCellProperty("body", index, "subcell");
    if (subCell > 0)
    {
        text = grid.getSubCellProperty("body", index, 0, "text");
    }
    else
    {
        text = grid.getCellProperty("body", index, "text");
    }
	
    if (!this.gfnIsNull(text))
    {
        if (text.search(/^BIND\(/) > -1)
        {
            columnid = text.replace(/^BIND\(/, "");
            columnid = columnid.substr(0, columnid.length - 1);
        }
        else if (text.search(/^bind:/) > -1)
        {
            columnid = text.replace(/^bind:/, "");
        }
    }
	
    return columnid;
}

/**
* Get the body cell matched to the head cell
* @param {Grid} grid Target Grid Component
* @param {number} headCellIndex head cell index
*/
this.getBodyCellIndex = function(grid, headCellIndex)
{
    // Max Head Row Index
    var maxHeadRow = 0;
    for (var i = 0, len = grid.getCellCount("head"); i < len; i++)
    {
        var row = grid.getCellProperty("head", i, "row");
        if (maxHeadRow < row)
        {
            maxHeadRow = row;
        }
    }
    // Max Body Row Index
    var maxBodyRow = 0;
    for (var i = 0, len = grid.getCellCount("body"); i < len; i++)
    {
        var row = grid.getCellProperty("body", i, "row");
        if (maxBodyRow < row)
        {
            maxBodyRow = row;
        }
    }
	
    if (maxHeadRow == 0 && maxBodyRow == 0)
    {
        return headCellIndex;
    }
	
    // When there is more than 1 Body Row
    // If the head row is larger than the body row, find the target by subtracting the difference row.
    // If the row of the body is greater than or equal to the row of the head, the row index is searched for the same object.
    var cellIndex = -1;
    var sRow = -1;
    var nRow = parseInt(grid.getCellProperty("head", headCellIndex, "row"));
    var nCol = parseInt(grid.getCellProperty("head", headCellIndex, "col"));
    var nColspan = parseInt(grid.getCellProperty("head", headCellIndex, "colspan"));
	
    if (maxHeadRow > maxBodyRow)
    {
        sRow = nRow - (maxHeadRow - maxBodyRow);
        sRow = (sRow < 0 ? 0 : sRow);
    }
    else
    {
        sRow = nRow;
    }
	
    var cRow, cCol, cColspan;
    for (var i = 0, len = grid.getCellCount("body"); i < len; i++)
    {
        cRow = parseInt(grid.getCellProperty("body", i, "row"));
        cCol = parseInt(grid.getCellProperty("body", i, "col"));
        cColspan = parseInt(grid.getCellProperty("body", i, "colspan"));
        // If there is no matching body cell, but the first item is found by colspan ..
        //if (sRow == cRow && nCol <= cCol && cCol < (nCol + nColspan)) 
        if (sRow == cRow && nCol == cCol && nColspan == cColspan)
        {
            cellIndex = i;
            break;
        }
    }
    return cellIndex;
}

//Excel export start==========================================================================================================================================================================================================

/**
* Excel Export
* @param {Grid} grid Target Grid Component
*/
this.fnExport = function(grid)
{
    if (this.gfnIsNull(this.ExcelExportObject00) == true)
    {
        this.ExcelExportObject00 = new ExcelExportObject();
		
        this.ExcelExportObject00.addEventHandler("onsuccess", this.ExcelExportObject00_onsuccess, this);
        this.ExcelExportObject00.addEventHandler("onerror", this.ExcelExportObject00_onerror, this);
        
        this.ExcelExportObject00.set_exportmessageprocess("%d [ %d / %d ]");
        this.ExcelExportObject00.set_exportuitype("exportprogress");
        this.ExcelExportObject00.set_exporteventtype("itemrecord");
        this.ExcelExportObject00.set_exporttype(nexacro.ExportTypes.EXCEL2007);
    }
    else
    {
        this.ExcelExportObject00.clear();
    }
	
    var ret = this.ExcelExportObject00.addExportItem(nexacro.ExportItemTypes.GRID, grid, "Sheet1!A1","allband","","merge","","image","none");
	
    this.ExcelExportObject00.set_exportfilename("ExcelExportTest");
    this.ExcelExportObject00.set_exporturl("xeni::XExportImport");
    this.ExcelExportObject00.exportData();
}

/**
* @description onsuccess
*/
this.ExcelExportObject00_onsuccess = function(obj: ExportObject, e: nexacro.ExportEventInfo)
{
	
}

/**
* @description onprogress
*/
this.ExcelExportObject00_onprogress = function(obj: ExportObject, e: nexacro.ExportProgressEventInfo)
{
	
}

//Excel export end==========================================================================================================================================================================================================


//Excel import start========================================================================================================================================================================================================

/**
* Excel import
*/
this.fnImport = function()
{
    this.importObj = null;
	
    if(this.importObj == null)
    {
        this.importObj = new nexacro.ExcelImportObject("Import00", this);
        this.importObj.set_importtype(nexacro.ImportTypes.EXCEL);
        this.importObj.addEventHandler("onsuccess", this.Import00_onsuccess, this);
        this.importObj.addEventHandler("onerror", this.Import00_onerror, this);
    }
	
    this.importObj.set_importurl("xeni::XImport"); 
    this.importObj.importData("", "[command=getsheetdata;output=outDs;body=Sheet1!B2;]", "[dsList=outDs]");
}

/**
* @description onsuccess
*/
this.Import00_onsuccess = function(obj: ExcelImportObject, e: nexacro.ExcelImportEventInfo)
{
	
}

//=========================================================== Excel import end =========================================================================================================================================

//=========================================================== Filter start =============================================================================================================================================

/******************************************************************************
Function common to mouse over filter function
******************************************************************************/

/**
* onlbuttondown Event Handler
* @param {Grid} obj Event가 발생한 Grid Component
* @param {GridMouseEventInfo} e GridMouseEventInfo
*/
this.filterGridOnLButtonDownHandler = function(obj, e)
{
    // head cell resize 시 필터가능 버튼을 숨기기위한 설정
    if (e.row == -1)
    {
        obj.celLResizeLbuttondown = true;
    }
}

/**
* onlbuttonup Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridMouseEventInfo} e GridMouseEventInfo
*/
this.filterGridOnLButtonUpHandler = function(obj, e)
{
    // Setting to hide the filterable button when resizing the head cell
    obj.celLResizeLbuttondown = false;
	
    // oncolresized is currently not supported and added to use the feature
    var resizer = obj._resizer_elem;
    var resizing = obj.colResizing;
    if (resizing && resizer && resizer._movedPos != 0)
    {
        this.arrangeOverFilterComps(obj);
    }
}

/**
* onmousemove Event Handler
* @param {Grid} obj Event가 발생한 Grid Component
* @param {GridMouseEventInfo} e GridMouseEventInfo
*/
this.filterGridOnMouseMoveHandler = function(obj, e)
{
    // oncolresized is currently not supported and added to use the feature
    var resizer = obj._resizer_elem;
    if (resizer && resizer._is_tracking)
    {
        obj.colResizing = true;
		
    }
    else
    {
        obj.colResizing = false;
    }
	
    // Setting to hide the filter related button when resizing the head cell
    var filterImage;
    var filterImages = obj.filterApplyComps;
	
    if (obj.celLResizeLbuttondown && e.row == -1)
    {
		
        var filterBtn = obj.filterButton;
        filterBtn.set_visible(false);
		
        for (var i = 0, len = filterImages.length; i < len; i++)
        {
			
            filterImage = filterImages[i];
			
            if (filterImage.visible && filterImage._filtered)
            {
				
                filterImages[i].set_visible(false);
            }
        }
        return;
		
    }
    else
    {
		
        var xy;
		
        for (var i = 0, len = filterImages.length; i < len; i++)
        {
			
            filterImage = filterImages[i];
			
            if (filterImage.visible == false && filterImage.filtered)
            {
				
                xy = this.getCompXYFromGridHeadCellRight(obj, filterImage.headCellIndex, filterImage);
				
                if (xy[0] > -1 && xy[1] > -1)
                {
					
                    filterImage.move(xy[0], xy[1]);
                    filterImage.set_visible(true);
					
                }
                else
                {
					
                    filterImage.set_visible(false);
                }
            }
        }
    }
	
    if (filterImage.filterPopupDiv.visible) return;
	
    var x = e.clientX;
    var y = e.clientY;
    var headRowSize = obj.getRealRowFullSize("head");
    var filterBtn = obj.filterButton;
	
    if (y < headRowSize)
    {
		
        var headCellIndex = e.cell;
		
        if (headCellIndex < 0)
        {
			
            filterBtn.set_visible(false);
            return;
        }
		
        if (this.getBodyCellIndex(obj, headCellIndex) > -1)
        {
			
            var xy = this.getCompXYFromGridHeadCellRight(obj, headCellIndex, filterBtn);
			
            if (xy[0] > -1 && xy[1] > -1)
            {
				
                filterBtn.move(xy[0], xy[1]);
                filterBtn.set_visible(true);
				
            }
            else
            {
				
                filterBtn.set_visible(false);
            }
			
            filterBtn.headCellIndex = headCellIndex;
			
        }
        else
        {
            filterBtn.set_visible(false);
        }
		
    }
    else
    {
        filterBtn.set_visible(false);
    }
}

/**
* onformatchanged Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridFormatChangedEventInfo} e GridFormatChangedEventInfo
*/
this.headOverFilterOnFormatChanged = function(obj, e)
{
    // Remove component for filter processing when format is changed
    // Component relocation for filter processing when cell is changed
    switch (e.reason)
    {
	case 10: //formatid 
	case 11: //formats 
		this.removeOverFilterComps(obj);
		break;
	case 21: //MoveCell 
	case 22: //colresize
		this.arrangeOverFilterComps(obj);
		break;
    }
}

/**
* ondragmove Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridDragEventInfo} e GridDragEventInfo
*/
this.filterGridOnDragMoveHandler = function(obj, e)
{
    // Check internal properties to check cell moving ...
    if (obj._movingcell)
    {
		
        var curCol = e.col;
        var col, colspan;
        var merged = false;
        var movingStartCol = obj._movingcell._refobj._col;
        var movingEndCol = curCol;
		
        // Check because the merged cell cannot enter the existing col
        for (var i = 0, len = obj.getCellCount("head"); i < len; i++)
        {
			
            colspan = obj.getCellProperty("head", i, "colspan") - 1;
			
            if (colspan > 0)
            {
				
                col = obj.getCellProperty("head", i, "col");
				
                if ((col <= curCol && curCol <= (col + colspan)) || ((col + colspan) <= curCol && curCol <= col))
                {
					
                    if (movingStartCol > movingEndCol)
                    {
						
                        movingEndCol = col;
						
                    }
                    else
                    {
						
                        movingEndCol = (col + colspan);
                    }
                    break;
                }
            }
        }
		
        if (movingStartCol != movingEndCol)
        {
			
            obj.isMovingCell = true;
            obj.movingStartCol = movingStartCol;
            obj.movingEndCol = movingEndCol;
            return;
        }
    }
	
    obj.isMovingCell = false;
}

/**
* ondrop Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridDragEventInfo} e GridDragEventInfo
*/
this.filterGridOnDropHandler = function(obj, e)
{
    // There is currently no onformatchanged function, so it is not known when the movecell occurs.
    // Therefore, check if it is moving in ondragmove and sell it after ondrop.
    if (e.row == -1 && obj.isMovingCell)
    {
		
        var movingStartCol = obj.movingStartCol;
        var movingEndCol = obj.movingEndCol;
        this.moveColumnInfo(obj, movingStartCol, movingEndCol);
    }
}

/**
* Adding filer function to the grid head Initialization
* @param {Grid} grid Target Grid Component
*/
this.initGridHeadAppendFilter = function(grid)
{
    // Add property to contain filter area (Div)
    if (this.fnIsUndefined(grid.makeCompList))
    {
		
        grid.makeCompList = [];
    }
	
    // Add properties to hold filter application information
    if (this.fnIsUndefined(grid.filterItems))
    {
		
        grid.filterItems = {};
    }
	
    // add ondragmove handler
    grid.addEventHandler("ondragmove", this.filterGridOnDragMoveHandler, this);
	
    // add ondrop handler
    grid.addEventHandler("ondrop", this.headAppendFilterOnDropHandler, this);
	
    // add onlbuttonup handler
    grid.addEventHandler("onlbuttonup", this.headAppendFilterOnLButtonUpHandler, this);
	
    // add onmousemove handler
    grid.addEventHandler("onmousemove", this.headAppendFilterOnMouseMoveHandler, this);
	
    // add onhscroll handler
    grid.addEventHandler("onhscroll", this.arrangeFilterComps, this);
}

/**
* onformatchanged Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridFormatChangedEventInfo} e GridFormatChangedEventInfo
*/
this.headAppendFilterOnFormatChanged = function(obj, e)
{
    // Remove component for filter processing when format is changed
    // Component relocation for filter processing when cell is changed
    switch (e.reason)
    {
	case 10: //formatid 
	case 11: //formats 
		this.removeFilterComps(obj);
		break;
	case 21: //MoveCell 
	case 22: //colresize
		this.arrangeFilterComps(obj);
		break;
    }
}

/**
* ondrop Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridDragEventInfo} e GridDragEventInfo
*/
this.headAppendFilterOnDropHandler = function(obj, e)
{
    // There is currently no onformatchanged function, so it is not known when the movecell occurs.
    // Therefore, the function is processed by checking the internal attribute value in ondrop
    var s = e.sourcereferenceobject;
    var f = e.fromreferenceobject;
	
    if (s._type_name == "GridCell" && f._type_name == "GridCell")
    {
		
        if (s.parent == f.parent && s._cellidx != f._cellidx)
        {
			
            this.arrangeFilterComps(obj);
        }
    }
}

/**
* onlbuttonup Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridMouseEventInfo} e GridMouseEventInfo
*/
this.headAppendFilterOnLButtonUpHandler = function(obj, e)
{
    // oncolresized is currently not supported and added to use the feature
    var resizer = obj._resizer_elem;
    if (obj.colResizing && resizer && resizer._movedPos != 0)
    {
		
        this.arrangeFilterComps(obj);
    }
}

/**
* onmousemove Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {GridMouseEventInfo} e GridMouseEventInfo
*/
this.headAppendFilterOnMouseMoveHandler = function(obj, e)
{
    // oncolresized is currently not supported and added to use the feature
    var resizer = obj._resizer_elem;
    if (resizer && resizer._is_tracking)
    {
		
        obj.colResizing = true;
		
    }
    else
    {
		
        obj.colResizing = false;
    }
}

/******************************************************************************
Unit function required for filter processing function
******************************************************************************/

/**
* Returns the coordinates of the component to be located in the right area of the grid head cell
* @param {Grid} grid Target Grid Component
* @param {number} headCellIndex Grid Head Cell Index
* @param {XPComp} comp Target component
* @return {array} x, y Coordinates (-1 if unable to locate)
*/
this.getCompXYFromGridHeadCellRight = function(grid, headCellIndex, comp)
{
    var col = grid.getCellProperty("head", headCellIndex, "col");
    var band = grid.getFormatColProperty(col, "band");
    var pivotIndex = this.gfnDecode(band, "left", -1, "right", -2, 0);
    var cellRect = grid.getCellRect(-1, headCellIndex, pivotIndex);
	
    var scrollWidth = this.fnGetCurrentScrollBarSize(grid, "vert");
    var gridLeft = grid.getOffsetLeft();
    var gridTop = grid.getOffsetTop();
    var gridAvailRight = gridLeft + grid.getOffsetWidth() - scrollWidth;
	
    var x = y = -1;
	
    if (gridLeft + cellRect.left < gridAvailRight)
    {
		
        if (cellRect.left < gridLeft)
        {
            cellRect.left = 0;
        }
		
        if (gridLeft + cellRect.right > gridAvailRight)
        {
            cellRect.right = gridAvailRight - gridLeft;
        }
		
        x = gridLeft + cellRect.left + (cellRect.width - comp.getOffsetWidth());
        y = gridTop + cellRect.top + Math.round((cellRect.height - comp.getOffsetHeight()) / 2);
		
        if (x < gridLeft)
        {
            x = -1;
        }
        if (y < gridTop)
        {
            y = -1;
        }
    }
	
    return [x, y];
}

/**
* Filter execution
* @param {Grid} grid Target Grid Component
* @param {number} headCellIndex head cell index
* @param {string} filterString Conditional expression to apply
* @param {*=} filterData filter Condition data
*/
this.executeFilter = function(grid, headCellIndex, filterString, filterData)
{
    var bodyCellIndex = this.getBodyCellIndex(grid, headCellIndex);
    var column = this.getBindColumnNameByIndex(grid, bodyCellIndex);
    var ds = grid.getBindDataset();
    var filterItems = grid.filterItems;
    var filterItem = filterItems[column];
    // Check and specify filter information of the selected column name
    if (this.fnIsUndefined(filterItem))
    {
        filterItem = filterItems[column] = {
            filterData: filterData,
            filterString: filterString
        };
		
    }
    else
    {
        filterItem.filterData = filterData;
        filterItem.filterString = filterString;
    }
	
    // Filter string combination in filter information
    var resultString = "";
    var tempString = "";
	
    for (var p in filterItems)
    {
		
        if (!filterItems.hasOwnProperty(p)) return;
		
        filterItem = filterItems[p];
        tempString = filterItem.filterString;
		
        if (!this.gfnIsNull(tempString))
        {
			
            resultString += (this.gfnIsNull(resultString) ? "" : " && ") + tempString;
        }
    }
	
    // 필터 적용
    ds.filter(resultString);
}

/**
* Grid head append filter Show
* @param {Grid} grid Target Grid Component
*/
this.showHeadAppendFilter = function(grid)
{
    var rowIdx = grid.appendContentsRow("head");
	grid.setFormatRowProperty( rowIdx, "size", 34 );//Added head height adjustment 2019-11-21 bok
	
    // Let's add the added head row index.
    grid.appendHeadRowIndex = rowIdx;
	
    this.arrangeFilterComps(grid);
}

/**
* Hide the grid head append filter (including filter removal)
* @param {Grid} grid Target Grid Component
*/
this.hideHeadAppendFilter = function(grid)
{
    var index = grid.appendHeadRowIndex;
    if (!this.fnIsUndefined(index))
    {
        grid.deleteContentsRow("head", index);
		
        // Hide Div and reset value
        var comps = grid.parent.components;
        var comp, list;
		list = grid.makeCompList;
        for (var i = 0, len = list.length; i < len; i++)
        {
            comp = comps[list[i]];
			
            if (comp)
            {
                comp.set_visible(false);
                comp.form.initValue();
            }
        }
		
        // Remove dataset filter
        var ds = grid.getBindDataset();
        ds.filter("");
		
        grid.appendHeadRowIndex = null;
    }
}

/**
* Removed components added to Grid head over filter function
* @param {Grid} grid 대상 Grid Component
*/
this.removeOverFilterComps = function(grid)
{
    var form = grid.parent;
    var comps = form.components;
    var comp, list = grid.filterApplyComps;
    var removed;
    for (var i = 0, len = list.length; i < len; i++)
    {
        comp = comps[list[i]];
        if (comp)
        {
            removed = form.removeChild(comp.name);
            removed.destroy();
        }
    }
}

/**
* Create and position components required for the Grid head over filter function
* @param {Grid} grid Target Grid Component
*/
this.arrangeOverFilterComps = function(grid)
{
    var form = grid.parent;
    var comp, comps = grid.filterApplyComps;
    var xy;
	
    for (var i = 0, len = comps.length; i < len; i++)
    {
        comp = comps[i];
        if (comp && comp.filtered)
        {
            xy = this.getCompXYFromGridHeadCellRight(grid, compheadCellIndex, comp);
            if (xy[0] > -1 && xy[1] > -1)
            {
                comp.move(xy[0], xy[1]);
                comp.set_visible(true);
            }
            else
            {
                comp.set_visible(false);
            }
        }
    }
}

/**
* Remove the components added to the Grid head append filter function
* @param {Grid} grid Target Grid Component
*/
this.removeFilterComps = function(grid)
{
    var form = grid.parent;
    var comps = form.components;
    var comp, list = grid.makeCompList;
    var removed;
    for (var i = 0, len = list.length; i < len; i++)
    {
        comp = comps[list[i]];
        if (comp)
        {
            removed = form.removeChild(comp.name);
            removed.destroy();
        }
    }
}

/**
* Create and position components required for the Grid head append filter function
* @param {Grid} grid Target Grid Component
*/
this.arrangeFilterComps = function(grid)
{
    var form = grid.parent;
    var index = grid.appendHeadRowIndex;
    var rect, rects = [];
    var cellCnt = grid.getCellCount("head");
    var bodyCellIndex, column, comp, name, type;
    var l, t, w, h;
    var list = grid.makeCompList;
    var seq = 0;
    var gridLeftPos = grid.getOffsetLeft();
    var gridTopPos = grid.getOffsetTop();
    var gridPos = [gridLeftPos, gridTopPos, gridLeftPos + grid.getOffsetWidth(), gridTopPos + grid.getOffsetBottom()];
    var first = true;
    var col, band, pivotIndex;
	
    // Create filter input area in each cell area
    for (var i = 0; i < cellCnt; i++)
    {
        if (grid.getCellProperty("head", i, "row") == index)
        {
            col = grid.getCellProperty("head", i, "col");
            band = grid.getFormatColProperty(col, "band");
            pivotIndex = this.gfnDecode(band, "left", -1, "right", -2, 0);
            rect = grid.getCellRect(-1, i, pivotIndex);
            bodyCellIndex = this.getBodyCellIndex(grid, i);
            column = this.getBindColumnNameByIndex(grid, bodyCellIndex);
            type = grid.getCellProperty("body", bodyCellIndex, "displaytype");
			
            if (this.fnIsUndefined(type)) type = "normal";
			
            name = grid.name + "_headAppendComp" + seq;
			
            var borderWidths = this.fnGetBorderWidth(grid);
            l = gridPos[0] + rect.left;
            t = gridPos[1] + rect.top + borderWidths[1];
            w = rect.width - 1;
            h = rect.height - 1;
			
            // Add if component does not exist
            if (this.fnIndexOf(list, name) < 0)
            {
                list.push(name);
                comp = new Div(name, l, t, w, h);
				//filter
				//comp.style.set_border("0px none white");
                comp.set_border("0px none white");
                comp.form.set_scrollbartype("none");
				comp.form.set_scrolltype("none");
                comp.set_async(false);
                comp.set_visible(false);
                //comp.style.set_background("red");
                form.addChild(comp.name, comp);
				
                comp.set_url("grid::GridFilterDiv.xfdl");
				
                comp.show();
            }
            else
            {
                comp = form.components[name];
            }
			
            // Assign reference value to Div
            comp.grid = grid;
            comp.headCellIndex = i;
            comp.bodyCellIndex = bodyCellIndex;
            comp.filterType = type;
            comp.filterColumn = column;
			
            var filterItems = grid.filterItems;
            var filterItem = filterItems[column];
            if (!this.gfnIsNull(filterItem))
            {
                comp.filterData = filterItem.filterData;
            }
			
            // Filter type designation
            comp.form.setFilterType();
			
            // Position adjustment
            if (l < gridPos[0])
            {
                l = gridPos[0];
            }
			
            if (l + grid.vscrollbar.getOffsetWidth() > gridPos[2])
            {
                comp.set_visible(false);
            }
            else
            {
                var scrollWidth = grid.vscrollbar.getOffsetWidth();
                if ((l + w) > gridPos[2] - scrollWidth)
                {
                    w = gridPos[2] - l;
                    if (grid.vscrollbar)
                    {
                        w = w - scrollWidth - 1;
                    }
                }
                comp.move(l + 1, t + 1, w, h);
                comp.set_visible(true);
            }
			
            seq++;
        }
    }
	
    var div = form.components[list[0]];
	
    if (!this.gfnIsNull(div)) div.setFocus();
}

/******************************************************************************
utility function
******************************************************************************/

/**
* Retrieves the column name bound by the body cell index.
* @param {Grid} grid Target Grid Component
* @param {number} index body cell index
*/
this.getBindColumnNameByIndex = function(grid, index)
{
    var text = "";
    var columnid = "";
    var subCell = grid.getCellProperty("body", index, "subcell");
    if (subCell > 0)
    {
        text = grid.getSubCellProperty("body", index, 0, "text");
    }
    else
    {
        text = grid.getCellProperty("body", index, "text");
    }
	
    if (!this.gfnIsNull(text))
    {
        if (text.search(/^BIND\(/) > -1)
        {
            columnid = text.replace(/^BIND\(/, "");
            columnid = columnid.substr(0, columnid.length - 1);
        }
        else if (text.search(/^bind:/) > -1)
        {
            columnid = text.replace(/^bind:/, "");
        }
    }
	
    return columnid;
}

/**
* Get the body cell matched to the head cell
* @param {Grid} grid 대상 Grid Component
* @param {number} headCellIndex head cell index
*/
this.getBodyCellIndex = function(grid, headCellIndex)
{
	// Max Head Row Index
	var maxHeadRow = 0;
	for (var i = 0, len = grid.getCellCount("head"); i < len; i++)
	{
		var row = grid.getCellProperty("head", i, "row");
		if (maxHeadRow < row)
		{
			maxHeadRow = row;
		}
	}
	// Max Body Row Index
	var maxBodyRow = 0;
	for (var i = 0, len = grid.getCellCount("body"); i < len; i++)
	{
		var row = grid.getCellProperty("body", i, "row");
		if (maxBodyRow < row)
		{
			maxBodyRow = row;
		}
	}
	
	if (maxHeadRow == 0 && maxBodyRow == 0)
	{
		return headCellIndex;
	}
	
	// When there is more than 1 Body Row
	// If the head row is larger than the body row, find the target by subtracting the difference row.
	// If the row of the body is greater than or equal to the row of the head, the row index is searched for the same object.
	var cellIndex = -1;
	var sRow = -1;
	var nRow = parseInt(grid.getCellProperty("head", headCellIndex, "row"));
	var nCol = parseInt(grid.getCellProperty("head", headCellIndex, "col"));
	var nColspan = parseInt(grid.getCellProperty("head", headCellIndex, "colspan"));
	
	if (maxHeadRow > maxBodyRow)
	{
		sRow = nRow - (maxHeadRow - maxBodyRow);
		sRow = (sRow < 0 ? 0 : sRow);
	}
	else
	{
		sRow = nRow;
	}
	
	var cRow, cCol, cColspan;
	for (var i = 0, len = grid.getCellCount("body"); i < len; i++)
	{
		cRow = parseInt(grid.getCellProperty("body", i, "row"));
		cCol = parseInt(grid.getCellProperty("body", i, "col"));
		cColspan = parseInt(grid.getCellProperty("body", i, "colspan"));
		// If there is no matching body cell, but the first item is found by colspan ..
		//if (sRow == cRow && nCol <= cCol && cCol < (nCol + nColspan)) 
		if (sRow == cRow && nCol == cCol && nColspan == cColspan)
		{
			cellIndex = i;
			break;
		}
	}
	return cellIndex;
}

//=========================================================== Find start ===================================================================

/******************************************************************************
A function that commonizes the find / replace function
******************************************************************************/

/**
* oncellclick Event Handler
* Changing the target column of the replace window when selecting a cell
* @param {Grid} obj Grid Component where the event occurred
* @param {GridClickEventInfo} e GridClickEventInfo
*/
this.gridFindReplaceOnCellClickHandler = function(obj, e)
{
    if (e.row > -1)
    {
        // Specify if the find / replace popup is floating
        var name = "_GridFindPop";
        var form = obj.parent;
        var div = form.components[name];
		
        if (div && div.visible)
        {
            div.targetGrid = obj;
        }
        else
        {
            name = "_GridFindReplacePop";
            div = form.components[name];
            if (div && div.visible)
            {
                div.targetGrid = obj;
                if (div.setColumnList)
                {
                    div.setColumnList(obj);
                }
            }
        }
    }
}

/**
* onrbuttondown Event Handler
* @param {Grid} obj Grid Component where the event occurred
* @param {MouseEventInfo} e MouseEventInfo
*/
this.gridFindReplaceOnRButtonDownHandler = function(obj, e)
{
    var col = e.col;
    var row = e.row;
    var cell = e.cell;
    var x = e.screenX;
    var y = e.screenY;
	
    // body
    if (row > -1 && cell > -1)
    {
        var pmnu = obj.rClickPopupMenu;
		
        // Add grid reference attribute to popup menu
        pmnu.grid = obj;
		
        pmnu.trackPopup(x, y);
    }
}

/**
* Find / Replace popup
* @param {Grid} grid Target Grid Component
* @param {string} type Find or replace
*/
this.showGridFindReplace = function(grid, type)
{
    var name, url;
    var width, height;
    var form = grid.parent;
    var div;
	
    if (type == "find")
    {
        name = "_GridFindPop";
        url = "grid::GridFindPop.xfdl";
        width = 318;
        height = 200;
		
        div = form.components["_GridFindReplacePop"];
        if (div && div.visible)
        {
            div.set_visible(false);
        }
    }
    else
    {
        name = "_GridFindReplacePop";
        url = "grid::GridFindReplacePop.xfdl";
        width = 318;
        height = 220;
		
        div = form.components["_GridFindPop"];
        if (div && div.visible)
        {
            div.set_visible(false);
        }
    }
	
    div = form.components[name];
    if (this.gfnIsNull(div))
    {
        // add div component
        var x = Math.round((form.getOffsetWidth() - width) / 2);
        var y = Math.round((form.getOffsetHeight() - height) / 2);
		
        div = new Div();
        div.init(name, x, y, width, height);
        div.set_border("1px solid gray");
        form.addChild(div.name, div);
		
        // Specify the grid to find / replace
        div.targetGrid = grid;
		
        div.set_async(false);
        div.show();
		
        div.set_url(url);
		
    }
    else
    {
        // Specify the grid to find / replace
        div.targetGrid = grid;
		
        if (type == "replace")
        {
            div.setColumnList(grid);
        }
        div.set_visible(true);
        div.setFocus();
        div.edt_find.setFocus();
    }
}

/**
* Add find / replace string
* @param {string} type Find or replace
* @param {string} text Target string
*/
this.appendFindReplaceCache = function(type, text)
{
    // Create string cache (add to application)
    var stringCache = application.gridFindReplaceStringCache;
    if (this.fnIsUndefined(stringCache))
    {
        stringCache = {
            'findList': [],
            'replaceList': []
        };
		
        application.gridFindReplaceStringCache = stringCache;
    }
	
    // If it is not in the list, it is inserted first and the already registered string is moved to the first.
    var list = stringCache[type + "List"];
    var index = this.fnIndexOf(list, text);
    if (index < 0)
    {
        list.splice(0, 0, text);
    }
    else
    {
        var i, tmp;
        index = parseInt(index, 10);
		
        if (index !== 0 &&
            0 <= index && index <= list.length &&
            0 <= 0 && 0 <= list.length)
        {
			
            tmp = list[index];
            if (index < 0)
            {
                for (i = index; i < 0; i++)
                {
                    list[i] = list[i + 1];
                }
            }
            else
            {
                for (i = index; i > 0; i--)
                {
                    list[i] = list[i - 1];
                }
            }
            list[0] = tmp;
        }
    }
}

/**
* Get a list of find / replace strings
* @param {string} type Find or replace
*/
this.getFindReplaceCache = function(type)
{
    // String cache
    var stringCache = application.gridFindReplaceStringCache;
    if (this.fnIsUndefined(stringCache))
    {
        return [];
    }
	
    return stringCache[type + "List"];
}

/**
* Through the bind information specified in the given body cell
* Returns the column type of the dataset.
* @param {Grid} grid Target Grid Component
* @param {number} cell Cell index to find
* @return {boolean} Data type.
*/
this.getBindColumnType = function(grid, cell)
{
    var dataType = null;
    var dataset = grid.getBindDataset();
    var bindColid = grid.getCellProperty("body", cell, "text");
    bindColid = bindColid.replace("bind:", "");
	
    if (!this.gfnIsNull(bindColid))
    {
        var colInfo = dataset.getColumnInfo(bindColid);
        if (!this.gfnIsNull(colInfo))
        {
            dataType = colInfo.type;
        }
    }
	
    return dataType;
}

/**
* Find the given string in the grid.
* @param {Grid} grid Target Grid Component
* @param {string} findText String to find
* @param {object} option Find option
* @return {array} Index of [row, cell] found.
*/
this.findGridText = function(grid, findText, option)
{
    // Specify the value to continue searching for the last found string when F3 occurs
    grid.lastFindText = findText;
    grid.lastFindOption = option;
	
    // Find option
    var direction = option.direction;
    var position = option.position;
    var scope = option.scope;
    var condition = option.condition;
    var strict = option.strict;
	
    var dataset = grid.getBindDataset();
    var startCell = (position == "current" ? grid.currentcell : grid.lastFindCell);
    var startRow = (position == "current" ? grid.currentrow : grid.lastFindRow);
	
    // When calling from replace (option.cell is specified only in replace)
    if (scope == "col" && !this.gfnIsNull(option.cell))
    {
        startCell = option.cell;
    }
	
    var findRow = findCell = -1;
    var rowCnt = dataset.rowcount;
    var bodyCellCnt = grid.getCellCount("body");
	
    // Register findText to list of strings to find before processing
    this.appendFindReplaceCache("find", findText);
	
    // Case sensitive
    if (!strict)
    {
        findText = findText.toUpperCase();
    }
	
    // Find full range
    if (scope == "all")
    {
        // Start cell adjustment
        if (direction == "prev")
        {
            startCell -= 1;
            if (startCell < 0)
            {
                startCell = bodyCellCnt - 1;
                startRow -= 1;
                if (startRow < 0)
                {
                    startRow = rowCnt - 1;
                }
            }
        }
        else
        {
            startCell += 1;
            if (startCell > (bodyCellCnt - 1))
            {
                startCell = 0;
                startRow += 1;
                if (startRow > (rowCnt - 1))
                {
                    startRow = 0;
                }
            }
        }
		
        var loopCnt = rowCnt;
        while (loopCnt > 0)
        {
            while (true)
            {
                // String comparison
                if (this.compareFindText(grid, startRow, startCell, findText, condition, strict))
                {
                    findRow = startRow;
                    findCell = startCell;
                    break;
                }
				
                // Direction (previous, next)
                if (direction == "prev")
                {
                    startCell -= 1;
                    if (startCell < 0)
                    {
                        break;
                    }
                }
                else
                {
                    startCell += 1;
                    if (startCell > (bodyCellCnt - 1))
                    {
                        break;
                    }
                }
            }
			
            if (findRow > -1 && findCell > -1) break;
			
            // Direction (previous, next)
            if (direction == "prev")
            {
                startRow -= 1;
                if (startRow < 0)
                {
                    startRow = rowCnt - 1;
                }
                startCell = (bodyCellCnt - 1);
            }
            else
            {
                startRow += 1;
                if (startRow > (rowCnt - 1))
                {
                    startRow = 0;
                }
                startCell = 0;
            }
			
            loopCnt--;
        }
    }
    else if (scope == "row")
    {
        // Finding a range of rows
		
        // Start cell adjustment
        if (direction == "prev")
        {
            startCell -= 1;
            if (startCell < 0)
            {
                startCell = bodyCellCnt - 1;
            }
        }
        else
        {
            startCell += 1;
            if (startCell > (bodyCellCnt - 1))
            {
                startCell = 0;
            }
        }
		
        var loopCnt = startCell + bodyCellCnt;
        while (loopCnt > 0)
        {
            // String comparison
            if (this.compareFindText(grid, startRow, startCell, findText, condition, strict))
            {
                findRow = startRow;
                findCell = startCell;
                break;
            }
			
            // Direction (previous, next)
            if (direction == "prev")
            {
                startCell -= 1;
                if (startCell < 0)
                {
                    startCell = bodyCellCnt - 1;
                }
            }
            else
            {
                startCell += 1;
                if (startCell > (bodyCellCnt - 1))
                {
                    startCell = 0;
                }
            }
            loopCnt--;
        }
    }
    else if (scope == "col")
    {
        // Finding a column range
		
        // Start cell adjustment
        if (direction == "prev")
        {
            startRow -= 1;
            if (startRow < 0)
            {
                startRow = rowCnt - 1;
            }
        }
        else
        {
            startRow += 1;
            if (startRow > rowCnt)
            {
                startRow = 0;
            }
        }
		
        var loopCnt = rowCnt;
        while (loopCnt > 0)
        {
            // String comparison
            if (this.compareFindText(grid, startRow, startCell, findText, condition, strict))
            {
                findRow = startRow;
                findCell = startCell;
                break;
            }
			
            // Direction (previous, next)
            if (direction == "prev")
            {
                startRow -= 1;
                if (startRow < 0)
                {
                    startRow = rowCnt - 1;
                }
            }
            else
            {
                startRow += 1;
                if (startRow > (rowCnt - 1))
                {
                    startRow = 0;
                }
            }
			
            loopCnt--;
        }
    }
	
    // Specify last found location
    // Initialize when changing the direction to find in the popup to "From scratch"
    if (findRow > -1 && findCell > -1)
    {
        grid.lastFindRow = findRow;
        grid.lastFindCell = findCell;
    }
	
    return [findRow, findCell];
}

/**
* Grid data corresponding to the cell index of a given row, and
* Compare strings and return the result found
* @param {Grid} grid Target Grid Component
* @param {number} row Row index to find
* @param {number} cell Cell index to find
* @param {string} findText String to find
* @param {string} condition Search conditions (equal / inclusion)
* @param {boolean} strict Case sensitive (true / false)
* @return {boolean} Find success.
*/
this.compareFindText = function(grid, row, cell, findText, condition, strict)
{
    var cellText = grid.getCellText(row, cell);
    var displayType = grid.getCellProperty("body", cell, "displaytype");
	
    // When displayType is normal
    // Change displayType by checking dataType
    if (this.gfnIsNull(displayType) || displayType == "normal")
    {
        var dataType = this.getBindColumnType(grid, cell);
        switch (dataType)
        {
		case 'INT':
		case 'FLOAT':
		case 'BIGDECIMAL':
			displayType = "number";
			break;
		case 'DATE':
		case 'DATETIME':
		case 'TIME':
			displayType = "date";
			break;
		default:
			displayType = "strign";
        }
    }
	
    // In the case of currency, the reverse slash (\) is different from the won (￦), so it is compared after removal.
    if (displayType == "currency")
    {
        var code = cellText.charCodeAt(0);
        if (code == 65510 || code == 92)
        {
            cellText = cellText.substr(1);
        }
		
        code = findText.charCodeAt(0);
        if (code == 65510 || code == 92)
        {
            findText = findText.substr(1);
        }
    }
	
    // Case sensitive
    if (!strict)
    {
        cellText = cellText.toUpperCase();
    }
	
    // Match / include
    if (condition == "equal")
    {
        if (findText == cellText)
        {
            return true;
        }
    }
    else
    {
        if (cellText.indexOf(findText) > -1)
        {
            return true;
        }
    }
	
    return false;
}

/**
* Display the search results on the grid.
* @param {Grid} grid Target Grid Component
* @param {number} findRow Index of rows found
* @param {number} findCell Cell index found
*/
this.markGridFindResult = function(grid, findRow, findCell)
{
    var dataset = grid.getBindDataset();
	
    dataset.set_rowposition(findRow);
	
    grid.setCellPos(findCell);
}

/**
* Finds the given string in the grid and replaces it with the string to replace.
* @param {Grid} grid Target Grid Component
* @param {string} findText String to find
* @param {string} replaceText String to replace
* @param {object} option Find option
* @param {boolean} whether to replace all
* @return {number} Number of changes.
*/
this.replaceGridText = function(grid, findText, replaceText, option, all)
{
    // Specify the value to continue searching for the last found string when F3 occurs
    grid.lastFindText = findText;
    grid.lastFindOption = option;
	
    if (this.gfnIsNull(all))
    {
        all = false;
    }
	
    // Options to find (replace scope only supports certain columns)
    var direction = option.direction;
    var position = option.position;
    var condition = option.condition;
    var strict = option.strict;
    var cell = option.cell;
	
    var dataset = grid.getBindDataset();
	
    // The scope of the replacement supports only certain columns.
    var startCell = option.cell;
    var startRow;
	
    if (position == "current")
    {
        startRow = grid.currentrow;
    }
    else
    {
        var lastReplaceRow = grid.lastReplaceRow;
        if (this.fnIsUndefined(lastReplaceRow))
        {
            startRow = 0;
        }
        else
        {
            startRow = lastReplaceRow;
        }
    }
	
    var results = [];
    var findRow = findCell = -1;
    var rowCnt = dataset.rowcount;
    var bodyCellCnt = grid.getCellCount("body");
	
    // Register in the list of strings to replace
    this.appendFindReplaceCache("replace", replaceText);
	
    // Case sensitive
    if (!strict)
    {
        findText = findText.toUpperCase();
    }
	
    // Change column range
    var result;
    var loopCnt = rowCnt;
    while (loopCnt > 0)
    {
        // String comparison
        if (this.compareFindText(grid, startRow, startCell, findText, condition, strict))
        {
            findRow = startRow;
            findCell = startCell;
            result = this.replaceGridCellText(grid, findRow, findCell, findText, replaceText, strict);
            results.push(result);
            if (!all) break;
        }
		
        // Direction (previous, next)
        if (direction == "prev")
        {
            startRow -= 1;
            if (startRow < 0)
            {
                startRow = rowCnt - 1;
            }
        }
        else
        {
            startRow += 1;
            if (startRow > (rowCnt - 1))
            {
                startRow = 0;
            }
        }
		
        loopCnt--;
    }
	
    // Specify last replace position
    grid.lastReplaceRow = findRow;
	
    return results;
}

/**
* The data corresponding to the row and cell indexes found by replacing are actually changed.
* @param {Grid} grid Target Grid Component
* @param {number} findRow Index of rows found
* @param {number} findCell Cell index found
* @param {string} findText String to find
* @param {string} replaceText String to replace
* @param {boolean} strict Case sensitive
*/
this.replaceGridCellText = function(grid, findRow, findCell, findText, replaceText, strict)
{
    var result = {
        'replace': true,
        'message': '처리되었습니다.',
        'row': findRow,
        'cell': findCell
    };
	
    // Test and process if the cell is actually input by expr etc.
    var dataset = grid.getBindDataset();
    dataset.set_rowposition(findRow);
    grid.setCellPos(findCell);
	
    var editable = grid.showEditor(true);
    if (editable)
    {
        grid.showEditor(false);
    }
    else
    {
        return;
    }
	
    var mask = grid.getCellProperty("body", findCell, "mask");
    if (typeof mask == "object")
    {
        mask = mask.toString();
    }
	
    var displayType = grid.getCellProperty("body", findCell, "displaytype");
    var editType = grid.getCellProperty("body", findCell, "edittype");
    var text = grid.getCellProperty("body", findCell, "text");
    var bindColid = text.replace("bind:", "");
	
    // displayType When is normal
    // Change displayType by checking dataType
    var dataType = this.getBindColumnType(grid, findCell);
    if (this.gfnIsNull(displayType) || displayType == "normal")
    {
        switch (dataType)
        {
		case 'INT':
		case 'FLOAT':
		case 'BIGDECIMAL':
			displayType = "number";
			break;
		case 'DATE':
		case 'DATETIME':
		case 'TIME':
			displayType = "date";
			break;
		default:
			displayType = "string";
        }
    }
	
    var replace;
    var replaceVal;
    var columnValue = dataset.getColumn(findRow, bindColid);
    var displayValue = grid.getCellText(findRow, findCell);
	
    if (displayType == "combo" && editType == "combo")
    {
        // Change when there is a combo list corresponding to the string to be changed
        var comboDataset = grid.getCellProperty("body", findCell, "combodataset");
        comboDataset = this.fnLookup(grid.parent, comboDataset);
        var comboCodeCol = grid.getCellProperty("body", findCell, "combocodecol");
        var comboDataCol = grid.getCellProperty("body", findCell, "combodatacol");
		
        var row = comboDataset.findRow(comboDataCol, replaceText);
        if (row > -1)
        {
            replaceVal = comboDataset.getColumn(row, comboCodeCol);
        }
        else
        {
            result.replace = false;
            result.message = "바꿀 문자열에 해당하는 데이터 없음";
        }
    }
    else if (displayType == "number" || displayType == "currency")
    {
        // In the case of currency, the reverse slash (\) is different from the won (￦), so it is changed after removal.
        if (displayType == "currency")
        {
            var code = findText.charCodeAt(0);
            if (code == 65510 || code == 92)
            {
                findText = findText.substr(1);
            }
			
            code = replaceText.charCodeAt(0);
            if (code == 65510 || code == 92)
            {
                replaceText = replaceText.substr(1);
            }
			
            code = displayValue.charCodeAt(0);
            if (code == 65510 || code == 92)
            {
                displayValue = displayValue.substr(1);
            }
        }
		
        // Change the string value to find from the value shown in the cell
		
        // Case sensitive
        if (strict)
        {
            displayValue = displayValue.replace(findText, replaceText);
        }
        else
        {
            displayValue = this.fnReplaceIgnoreCase(displayValue, findText, replaceText);
        }
		
        // Remove non-numeric
        replaceVal = this.replaceNumberMaskValue(displayValue);
    }
    else if (displayType == "date")
    {
        if (columnValue == null)
        {
            // Like "0000-01-01" when there is no value
            // It may be found in the text.
            result.replace = false;
            result.message = "유효한 날짜가 아닙니다.";
        }
        else
        {
            // If there is no mask attribute, get the editformat of calendar (yyyy-MM-dd)
            if (this.gfnIsNull(mask))
            {
                mask = grid.controlcalendar.editformat;
            }
			
            var ret = this.replaceDateMaskValue(columnValue, displayValue, findText, replaceText, mask, strict);
            replaceVal = ret[1];
			
            if (ret[0] == false)
            {
                result.replace = false;
                result.message = ret[2];
            }
        }
    }
    else
    {
        if (this.gfnIsNull(mask))
        {
            // Case sensitive
            if (strict)
            {
                replaceVal = columnValue.replace(findText, replaceText);
            }
            else
            {
                replaceVal = this.fnReplaceIgnoreCase(columnValue, findText, replaceText);
            }
        }
        else
        {
            var maskChar = grid.getCellProperty("body", findCell, "maskchar");
            replaceVal = this.replaceStringMaskValue(columnValue, displayValue, findText, replaceText, mask, maskChar, strict);
        }
    }
	
    if (result.replace)
    {
        dataset.setColumn(findRow, bindColid, replaceVal);
    }
	
    return result;
}

/**
* Retrieves the actual value from a numeric masked string.
* @param {string} numString Numeric string
* @return {string} Converted string
*/
this.replaceNumberMaskValue = function(numString)
{
    numString = numString.trim();
	
    var numReg = /[0-9]/;
    var bPoint = false; // Only one decimal point is accepted.
    var bInside = false; // The sign is recognized only before the number appears.
    var c, buf = [];
	
    for (var i = 0, len = numString.length; i < len; i++)
    {
        c = numString.charAt(i);
        if ((c == '+' || c == '-') && (bInside === false))
        {
            // The sign is recognized only before the number appears.
            buf.push(c);
            bInside = true;
        }
        else if (numReg.test(c))
        {
            // Recognized for numbers.
            buf.push(c);
            bInside = true;
        }
        else if (c == "." && bPoint === false)
        {
            // Only one decimal point is accepted.
            buf.push(c);
            bPoint = true;
            bInside = true;
        }
        else if (c != ",")
        {
            return "";
        }
    }
    return buf.join("");
}

/**
*Retrieves the actual value from a date-masked string.
* @param {*} columnValue Actual value of dataset before change
* @param {string} displayValue String shown
* @param {string} findText String to find
* @param {string} replaceText String to replace
* @param {string} mask Mask attribute value
* @param {boolean} strict Case sensitivity
* @return {object} Conversion information (date or not, changed string, error message)
*/
this.replaceDateMaskValue = function(columnValue, displayValue, findText, replaceText, mask, strict)
{
    if (this.gfnIsNull(replaceText))
    {
        // Padding so that the string to be replaced is not empty
        replaceText = replaceText.padRight(findText.length, " ");
    }
	
    // 1. Find the string from the currently visible value and change it to the string to replace
    var replaceDisplayValue;
	
    // Case sensitive
    if (strict)
    {
        replaceDisplayValue = displayValue.replace(findText, replaceText);
    }
    else
    {
        replaceDisplayValue = this.fnReplaceIgnoreCase(displayValue, findText, replaceText);
    }
	
    // If there is no value to replace, remove the value.
    if (this.gfnIsNull(replaceDisplayValue.trim()))
    {
        return [true, null];
    }
	
    // 2. mask character separation
    var arrMask = this.parseDateMask(mask);
	
    // 3. While comparing the changed value with the mask value, extract the actual value and judge the effective date
    var tmpStr = "";
    var isDate = true;
    var errorMsg = "";
    var valueIndex = 0;
    var displayIndex = 0;
    var dateValue = [];
    var errorValue = [];
    var checkMask;
    var checkDayIndex = -1;
    var checkYearValue = "";
    var checkMonthValue = "";
	
    for (var i = 0, len = arrMask.length; i < len; i++)
    {
        checkMask = arrMask[i];
        if (!this.fnIsNumber(checkMask))
        {
            switch (checkMask)
            {
			case 'yyyy':
				tmpStr = replaceDisplayValue.substr(displayIndex, 4);
				
				if (tmpStr.length != 4 || !nexacro.isNumeric(tmpStr))
				{
					isDate = false;
					errorMsg = "연도가 올바르지 않습니다.";
				}
				
				// For date check
				checkYearValue = tmpStr;
				
				dateValue[dateValue.length] = tmpStr.trim(" ");
				errorValue[errorValue.length] = tmpStr.trim(" ");
				displayIndex += 4;
				valueIndex += 4;
				break;
			case 'yy':
			case 'MM':
			case 'dd':
			case 'hh':
			case 'HH':
			case 'mm':
			case 'ss':
				tmpStr = replaceDisplayValue.substr(displayIndex, 2);
				
				if (tmpStr.length == 2 && nexacro.isNumeric(tmpStr))
				{
					if (checkMask == "yy")
					{
						// Fill the first two digits with the original data.
						tmpStr = columnValue.substr(valueIndex, 2) + tmpStr;
						
						// For date check
						checkYearValue = tmpStr;
					}
					else if (checkMask == "MM")
					{
						if (parseInt(tmpStr) < 1 || parseInt(tmpStr) > 12)
						{
							isDate = false;
							errorMsg = "월이 올바르지 않습니다.";
						}
						
						// For date check
						checkMonthValue = tmpStr;
					}
					else if (checkMask == "dd")
					{
						// The year is required to apply the leap year.
						// Unconditionally the year (yyyy, yy) precedes the day (dd)
						// Since there is no guarantee, check after the loop ends.
						checkDayIndex = dateValue.length;
					}
					else if (checkMask == "hh" || checkMask == "HH")
					{
						if (parseInt(tmpStr) < 0 || parseInt(tmpStr) > 23)
						{
							isDate = false;
							errorMsg = "시간이 올바르지 않습니다.";
						}
					}
					else if (checkMask == "mm" || checkMask == "ss")
					{
						if (parseInt(tmpStr) < 0 || parseInt(tmpStr) > 59)
						{
							isDate = false;
							errorMsg = "분이 올바르지 않습니다.";
						}
					}
				}
				else
				{
					isDate = false;
					errorMsg = "날짜 형식이 올바르지 않습니다.";
				}
				
				dateValue[dateValue.length] = tmpStr.trim(" ");
				errorValue[errorValue.length] = tmpStr.trim(" ");
				displayIndex += 2;
				valueIndex += 2;
				break;
            } // end switch
        }
        else
        {
            // dateValue is the value to be applied, so let's skip
			
            // If it is not a mask character, it is a display character.
            errorValue[errorValue.length] = displayValue.charAt(checkMask);
            displayIndex += 1;
        }
    }
	
    // Date validity check
    if (!this.gfnIsNull(checkYearValue) &&
        !this.gfnIsNull(checkMonthValue) && checkDayIndex > -1)
    {
        var dt = checkYearValue + checkMonthValue + "01";
        var inputDay = parseInt(dateValue[checkDayIndex]);
        var lastDay = this.fnGetLastDayOfMonth(dt);
		
        if (inputDay < 1 || inputDay > lastDay)
        {
            isDate = false;
			
            var isLeapYear = this.fnIsLeapYear(dt);
            if (!isLeapYear && inputDay == 29)
            {
                //errorMsg = "해당 연도는 윤년이 아닙니다.";
				errorMsg = "The year is not a leap year.";
            }
            else
            {
                //errorMsg = "일자가 올바르지 않습니다.";
				errorMsg = "The date is incorrect.";
            }
        }
    }
	
    if (isDate)
    {
        return [isDate, dateValue.join("")];
    }
    else
    {
        return [isDate, errorValue.join(""), errorMsg];
    }
}

/**
* Parse date masks.
* @param {string} mask Mask attribute value
* @return {array} Syntax value
*/
this.parseDateMask = function(mask)
{
    /*  
	Grid Support Date Mask Character
	
	yyyy,yy : year
	MM : month
	dd : day
	ddd : Day of the week
	hh : hour
	mm : minute
	ss : second
	
	If there is no grid mask attribute, the calendar's editformat is fetched.
	More mask characters are supported.
	However, since it does not work properly in the grid, exclude it.
    */
	
    var dateMaskCache = application.dateMaskCache;
    if (this.fnIsUndefined(dateMaskCache))
    {
        application.dateMaskCache = {};
		
        dateMaskCache = application = dateMaskCache;
    }
	
    var arrMask = dateMaskCache[mask];
    if (arrMask) return arrMask;
	
    arrMask = [];
	
    var maskArr = mask.split("");
    var tmpStr = "";
    var tokenStr = "";
    var seq = 0;
	
    for (var i = 0, len = mask.length; i < len;)
    {
        tmpStr = mask.substr(i, 4);
        if (tmpStr == "yyyy")
        {
            arrMask[seq] = tmpStr;
            i += 4;
            seq++;
            continue;
        }
		
        // ddd => day of the week cannot be entered.
        tmpStr = mask.substr(i, 3);
        if (tmpStr == "ddd")
        {
            //arrMask[seq] = tmpStr;
            i += 3;
            //seq++;
            continue;
        }
		
        // For hh (Calendar is HH and grid works both)
        tmpStr = mask.substr(i, 2);
        if (tmpStr == "yy" || tmpStr == "MM" || tmpStr == "dd" ||
            tmpStr == "HH" || tmpStr == "hh" || tmpStr == "mm" || tmpStr == "ss")
        {
            arrMask[seq] = tmpStr;
            i += 2;
            seq++;
            continue;
        }
		
        tokenStr = maskArr[i];
		
        // Skip because it is not entered.
        if (tokenStr == "H" || tokenStr == "M" ||
            tokenStr == "d" || tokenStr == "m" || tokenStr == "s")
        {
            //arrMask[seq] = tokenStr;
            //seq++;
        }
        else
        {
            arrMask[seq] = i;
            seq++;
        }
        i++;
    }
	
    dateMaskCache[mask] = arrMask;
	
    return arrMask;
}


/**
* Parse the character mask.
* @param {string} strMask Mask attribute value
* @param {string} maskChar Mask character
* @return {array} Syntax value
*/
this.parseStringMask = function(strMask, maskChar)
{
    var stringMaskCache = application.stringMaskCache;
    if (this.fnIsUndefined(stringMaskCache))
    {
        application.stringMaskCache = {};
		
        stringMaskCache = application.stringMaskCache;
    }
	
    var res = stringMaskCache[strMask];
    if (res) return res;
	
    var len = strMask.length,
	arrMask = [],
	arrPass = [],
	arrOrgMask = [],
	bQuote = false,
	bEscape = false,
	bPasswd = false,
	Mask = 0,
	i, nIdx,
	cMasks = strMask.split(""),
	rmaskChar,
	ReserveMasks = this._stringMaskChar;
	
    for (i = 0, nIdx = 0; i < len; i++)
    {
        if (bEscape == false && cMasks[i] == "'")
        { // When the mask starts quotation.
            if (bQuote == false)
			bQuote = true;
            else
			bQuote = false;
            continue;
        }
        Mask = 0;
        if (bEscape == false && cMasks[i] == "\\" && !bQuote)
        { // When entering Escape from Mask.
            bEscape = true;
            continue;
        }
        else if (bEscape)
        { // When using Escape in Mask.
            bEscape = false;
        }
        else if (bQuote == false)
        { // About the characters outside the Quotation in Mask.
            rmaskChar = ReserveMasks[cMasks[i]];
            if (rmaskChar)
            {
                Mask = rmaskChar;
            }
            if (cMasks[i] == "{")
            {
                bPasswd = true;
                continue;
            }
            if (cMasks[i] == "}")
            {
                bPasswd = false;
                continue;
            }
        }
        arrMask[nIdx] = Mask;
        arrPass[nIdx] = bPasswd;
        arrOrgMask[nIdx] = cMasks[i];
        nIdx++;
    }
	
    res = [arrMask, arrPass, arrOrgMask];
    stringMaskCache[strMask] = res;
    return res;
}

/**
* Retrieves the actual value from a character masked string.
* @param {*} columnValue Actual value of dataset before change
* @param {string} displayValue String shown
* @param {string} findText String to find
* @param {string} replaceText 바꿀 문자열
* @param {string} strMask Mask attribute value
* @param {string} maskChar Mask character
* @param {boolean} strict Case sensitivity
* @return {string} Conversion value string
*/
this.replaceStringMaskValue = function(columnValue, displayValue, findText, replaceText, strMask, maskChar, strict)
{
	if (this.gfnIsNull(replaceText))
	{
		// Padding so that the string to be replaced is not empty
		replaceText = replaceText.padRight(findText.length, this._chkEmpty);
	}
	
	// 1. Find the string from the currently visible value and change it to the string to replace
	var replaceDisplayValue;
	
	// Case sensitive
	if (strict)
	{
		replaceDisplayValue = displayValue.replace(findText, replaceText);
	}
	else
	{
		replaceDisplayValue = this.fnReplaceIgnoreCase(displayValue, findText, replaceText);
	}
	
	// 2. mask character separation
	var maskInfo = this.parseStringMask(strMask, maskChar);
	
	// 3. Extract the actual value matching the mask character
	var arrMask = maskInfo[0],
	arrPass = maskInfo[1],
	arrVal = replaceDisplayValue.split(""),
	arrOrg = columnValue.split(""),
	stringValues = [],
	c;
	
	for (var i = 0, len = arrMask.length; i < len; i++)
	{
		if (arrMask[i] != 0)
		{
			c = arrVal[i];
			
			if (arrPass[i])
			{
				// Password, but the word to be replaced is the same or the original value
				if (c == "*" || this.gfnIsNull(c) || c == this._chkEmpty)
				{
					c = arrOrg[i];
				}
			}
			else
			{
				if (this.gfnIsNull(c) || c == this._chkEmpty)
				{
					c = "";
				}
			}
			stringValues[i] = c;
		}
	}
	
	return stringValues.join("");
}

//=========================================================== Find end ===================================================================


//===================================================== fnBlockChk/unchk start ==========================================================

/**
* Implementation of all grid selection functions
* @param {Grid} objGrid Corresponding grid
*/
this.fnBlockChk = function(objGrid)
{
    var objDs = objGrid.getBindDataset();
	
    for (var i = 0; i <= objDs.rowcount; i++)
    {
        objDs.setColumn(i, "chk", "1");
    }
    objGrid.setCellProperty("Head", 0, "text", "1");
}

/**
* Implementation of all grid selection functions
* @param {Grid} objGrid Corresponding grid
*/
this.fnBlockUnChk = function(objGrid)
{
	var objDs = objGrid.getBindDataset();
	
	for (var i = 0; i <= objDs.rowcount; i++)
	{
		objDs.setColumn(i, "chk", 0);
	}
	objGrid.setCellProperty("Head", 0, "text", "0");
}

//====================================================== fnBlockChk end ===============================================================

//====================================================== Hide start ===============================================================

/**
* Hide grid columns
* @param {Grid} objGrid Corresponding grid
* @param {number} nCell Corresponding grid headCellIndex
*/
this.fnHide = function(objGrid, nCell)
{
    var nCol = objGrid.getCellProperty("Head", nCell, "col");
	
    objGrid.hidelist = objGrid.hidelist + nCell + "|" + objGrid.getFormatColProperty(nCol, "size") + "|";
    objGrid.setFormatColProperty(nCol, "size", 0);
}

/**
* Unhide grid columns
* @param {Grid} objGrid Corresponding grid
* @param {number} nCell Corresponding grid headCellIndex
*/
this.fnHideCancel = function(objGrid, nCell)
{
    var arrHideList = objGrid.hidelist.split("|");
    objGrid.setFormatColProperty(arrHideList[arrHideList.length - 3], "size", arrHideList[arrHideList.length - 2]);
    objGrid.hidelist = objGrid.hidelist.replace(arrHideList[arrHideList.length - 3] + "|" + arrHideList[arrHideList.length - 2] + "|", "")
}

/**
* Hide Grid Columns Cancel All
* @param {Grid} objGrid Corresponding grid
* @param {number} nCell Corresponding grid headCellIndex
*/
this.fnHideCancelAll = function(objGrid, nCell)
{
    var i;
    var arrHideList = objGrid.hidelist.split("|");
	
    for (i = arrHideList.length - 2; i > -1; i = i - 2)
    {
        objGrid.setFormatColProperty(arrHideList[i - 1], "size", arrHideList[i]);
    }
    objGrid.hidelist = "";
}

//====================================================== Hide end ===============================================================

//===================================================== cellFix/Free start ========================================================

/**
* Grid column fixation
* @param {Grid} objGrid Corresponding grid
* @param {number} nCell Corresponding grid CellIndex
*/
this.fnCellFix = function(objGrid, nCell)
{
    nCell = this.colIdx;
	
    this.nCell1 = nCell;
    var nCol = objGrid.getCellProperty("Head", nCell, "col");
    var nColSpan = objGrid.getCellProperty("Head", nCell, "colspan");
    var nVal = objGrid.getCellpos
    var nMaxCol = 0;
	
    objGrid.set_enableredraw(false);
    if (nMaxCol < (nCol + nColSpan))
    {
        nMaxCol = nCol + nColSpan;
    }
	
    objGrid.setFormatColProperty(nMaxCol - 1, "band", "left");
    objGrid.fixCol = nMaxCol;
	
    objGrid.set_enableredraw(true);
    this.cellFixFalg = "on";
}

/**
* Grid Column Cancellation
* @param {Grid} objGrid Corresponding grid
*/
this.fnCellFree = function(objGrid)
{
    objGrid.set_enableredraw(false);
	
    objGrid.setFormatColProperty(0, "band", "body");
	
    objGrid.set_enableredraw(true);
	
    this.colIdx = -1;
    this.nCell1 = "";
    this.cellFixFalg = "off";
}

/**
* Fixed grid row
* @param {Grid} objGrid Corresponding grid
* @param {number} nCell Corresponding grid RowIndex
*/
this.fnRowFix = function(objGrid, nRow)
{
    //Return if no row is selected
    if (nRow < 0)
	return;
	
    //Lock row to selected row
    objGrid.setFixedRow(nRow);
}

/**
* Unpin grid rows
* @param {Grid} objGrid Corresponding grid
*/
this.fnRowFree = function(objGrid)
{
	//Initialization
	objGrid.setFixedRow(-1);
}

//===================================================== cellFix/Free end ========================================================

/**
* Save grid format
* @param {Grid} objGrid Corresponding grid
*/
this.fnSetGridFormat = function(objGrid)
{
    nexacro.setPrivateProfile("usrGrid_formats", objGrid.getCurFormatString());
}

/**
* Import grid format
* @param {Grid} objGrid Corresponding grid
*/
this.fnGetGridFormat = function(objGrid)
{
    var usrGrid_formats = nexacro.getPrivateProfile("usrGrid_formats");
	
    if (this.gfnIsNull(usrGrid_formats) == false)
    {
        objGrid.set_formats(("<Formats>" + usrGrid_formats + "</Formats>").replace("▼", "").replace("▲", ""));
    }
}

/**
* Initialize the grid format area
* @param {Grid} objGrid Corresponding grid
*/
this.fnClearGridFormat = function(objGrid)
{
	var usrGrid_formats = objGrid.orgFormat;
	objGrid.set_formats(("<Formats>" + usrGrid_formats + "</Formats>").replace("▼", "").replace("▲", ""));
	nexacro.setPrivateProfile("usrGrid_formats", "");
	
	objGrid.set_fastvscrolltype("default");
}

//=========================================================== Filter End ===================================================================

/************************************************************************************************
* EVENT area for each COMPONENT
************************************************************************************************/

/**
* @description Form timer
*/
this.Functions_ontimer = function(obj: Form, e: nexacro.TimerEventInfo)
{
    if (e.timerid == 1)
    {
        this.killTimer(1);
        
        this.edtSearch.setFocus();
        //this.calFrom.set_value("20190101");
        //this.calTo.set_value(this.gfnGetDate());
        
        this.fnSetGrid(this.grdList);
    }
}

/**
* @description gridonheadclick
*/
this.gridonheadclick = function(obj, e)
{
    var multiple = false;
	
    if (e.col == 0)
    {
        if (this.chkFlag == "1")
        {
            this.fnBlockUnChk(obj);
            this.chkFlag = "0";
        }
        else
        {
            this.fnBlockChk(obj);
            this.chkFlag = "1";
        }
    }
    else
    {
        // Shift 키
        if (e.shiftKey) multiple = true;
		
        // Ctrl 키
        if (e.ctrlKey) multiple = true;
		
        if (this.setSortStatus(obj, e.cell, multiple))
        {
            this.executeSort(obj);
        }
    }
}

/**
* @description userSearch
*/

this.edt_Search_onkeydown = function(obj:nexacro.Edit,e:nexacro.KeyEventInfo)
{
	var startDate = parseInt(this.calFrom.value);
	var endDate = parseInt(this.calTo.value);
	
	if(e.keycode == 13)
	{
		if(!this.edtSearch.text.length > 0)
		{
			this.dsList.filter("");
		}
		else
		{
			if(endDate > startDate)
			this.dsList.filter("Column0 == '" + obj.text + "'");
			else
			alert("시작일은 종료일보다 클 수 없습니다.");
		}
	}
};

/**
* @description onkeyup 
*/

this.edt_Search_onkeyup = function(obj:nexacro.Edit,e:nexacro.KeyEventInfo)
{
	var startDate = parseInt(this.calFrom.value);
	var endDate = parseInt(this.calTo.value);
	
	if(endDate > startDate)
		this.dsList.filter("String(Column0).indexOf('" + obj.text + "') >= 0");
	else
		alert("시작일은 종료일보다 클 수 없습니다.");
};




/************************************/
this.targetGrid = null;

this.fn_setCPGrid = function(obj)
{	
	obj.pForm = this;
	var form = obj.parent;
	
	//add onkeydown handler
	obj.addEventHandler("onkeydown", this.gridCopyOnkeydown, this);
	this.addEventHandler("ontimer", this.gridCopyTimerHandler, form);
};

this.COL_SEPERATOR = "\t";
this.ROW_SEPERATOR = "\r\n";

/**
* copy & paste processing
* @param {Grid} obj Grid Component where the event occurred
* @param {KeyEventInfo} e KeyEventInfo
* @memberOf nxlib.grid
*/

this.gridCopyOnkeydown = function (obj, e)
{
	var keycode = e.keycode;
	var form = obj.pForm;
	
	if (system.navigatorname == "nexacro") 
	{	
		if (e.ctrlkey && !e.shiftkey && !e.altkey) 
		{
			if(keycode == 67) 
			{
				if(this.rdoSelectType.value == "row" || this.rdoSelectType.value == "multirow")
				{	
					var value="", clipText = "";
					
					//row
					if(obj.selectstartrow.length < 2 || obj.selectendrow.length < 2)
					{
						if(obj.selectendrow[0] > obj.selectstartrow[0])
						{
							//row(multirow)
							for(var i=obj.selectstartrow[0]; i<=obj.selectendrow[0]; i++)
							{
								for(var j=1; j<obj.getFormatColCount(); j++)
								{
									value = obj.getCellValue(i, j);
									clipText += value + this.COL_SEPERATOR;
								}
								clipText += this.ROW_SEPERATOR;
							}
						}
						else
						{
							//row
							for(var i=1; i<obj.getFormatColCount(); i++)
							{
								value = obj.getCellValue(obj.selectstartrow[0], i);
								clipText += value + this.COL_SEPERATOR;
							}
						}
					}
					//multirow
					else
					{
						//Sort in ascending order: to print in order
						obj.selectstartrow.sort(function(left, right) {
							return left-right;
						});
						
						obj.selectendrow.sort(function(left, right) {
							return left-right;
						});
						
						for(var i=0; i<obj.selectstartrow.length; i++)
						{
							//When selecting single row in multirow
							if(obj.selectstartrow[i] == obj.selectendrow[i])
							{
								for(var j=1; j<obj.getFormatColCount(); j++)
								{
									value = obj.getCellValue(obj.selectstartrow[i], j);
									clipText += value + this.COL_SEPERATOR;
								}
								clipText += this.ROW_SEPERATOR;
							}
							//multirow to multi-row selection
							else
							{
								for(var j=obj.selectstartrow[i]; j<=obj.selectendrow[i]; j++)
								{
									for(var k=1; k<obj.getFormatColCount(); k++)
									{
										value = obj.getCellValue(j, k);
										clipText += value + this.COL_SEPERATOR;
									}
									clipText += this.ROW_SEPERATOR;
								}
							}
						}
					}
					
					system.clearClipboard();
					system.setClipboard("CF_TEXT", clipText);
					
					form.targetGrid = obj;
					
					return;
				}
				
				if(obj.selectstartrow.length >= 2 || obj.selectendrow.length >= 2 || obj.selectstartcol.length >= 2 || obj.selectendcol.length >= 2)
				{	
					//Horizontal area designation variable
					var nFlag1 = 0, nFlag3 = 0;
					
					//Vertical area designation variable
					var nFlag2 = 0, nFlag4 = 0;
					
					//When nFlag1 is 1: Specify multiple rows
					//When nFlag1 is 0: Specify single row
					for(var i=1; i<obj.selectstartrow.length; i++)
					{
						if(obj.selectstartrow[0] != obj.selectstartrow[i])
							nFlag1 = 1;
					}
					
					//When nFlag2 is 1: Specify multiple columns
					//nFlag2 가 0일때 : 단일 열 지정
					for(var i=1; i<obj.selectstartcol.length; i++)
					{
						if(obj.selectstartcol[0] != obj.selectstartcol[i])
							nFlag2 = 1;
					}
					
					//When dragging the horizontal area and specifying the CTRL cell
					//When the row is the same and the col is different
					if(nFlag1 == 0 && nFlag2 == 1) 
					{	
						var clipText = "";
						
						//When nFlag3 is 0: for one col
						//When nFlag3 is 1: For multiple cols
						for(var i=0; i<obj.selectstartrow.length; i++)
						{
							if(obj.selectstartrow[i] != obj.selectendrow[i])
								nFlag3 = 1;
						}
						
						if(nFlag3 == 0) 
						{	
							//Sort in ascending order: to print in order
							obj.selectstartcol.sort(function(left, right) {
								return left-right;
							});
							
							obj.selectendcol.sort(function(left, right) {
								return left-right;
							});
							
							for(var k=0; k<obj.selectstartcol.length; k++)
							{
								for(var i=obj.selectstartcol[k]; i<=obj.selectendcol[k]; i++)
								{
									var value = "";
									
									if(!this.gfnIsNull(obj.getCellValue(obj.selectstartrow[k], i)))
									{
										value = obj.getCellValue(obj.selectstartrow[k], i);
										clipText += value + this.COL_SEPERATOR;
									}
								}
							}
						}
						else if(nFlag3 == 1)
						{
							var temp = Math.abs(obj.selectendrow[0] - obj.selectstartrow[0]);
							
							var arrayRowIndex_Start = new Array();
							var arrayRowIndex_End = new Array();
							var arrayColIndex_Start = new Array(); 
							var arrayColIndex_End = new Array(); 
							
							for(var i=0; i<obj.selectstartrow.length; i++)
							{	
								if(i != 0)
								{
									if(temp != Math.abs(obj.selectendrow[i] - obj.selectstartrow[i]))
									{
										//alert("다중 선택 범위에서는 사용할 수 없는 명령입니다.");
										alert("This command is not available in multiple selection ranges.");
										return;
									}
								}
							}	
							
							for(var i=0; i<obj.selectstartrow.length; i++)
							{
								arrayRowIndex_Start.push(nexacro.toNumber(obj.selectstartrow[i]));
								arrayRowIndex_End.push(nexacro.toNumber(obj.selectendrow[i]));
								arrayColIndex_Start.push(nexacro.toNumber(obj.selectstartcol[i]));
								arrayColIndex_End.push(nexacro.toNumber(obj.selectendcol[i]));
							}
							
							//Sort in ascending order: to get the outermost coordinates.
							arrayRowIndex_Start.sort(function(left, right) {
								return left-right;
							});
							
							arrayRowIndex_End.sort(function(left, right) {
								return left-right;
							});
							
							arrayColIndex_Start.sort(function(left, right) {
								return left-right;
							});
							
							arrayColIndex_End.sort(function(left, right) {
								return left-right;
							});
							
							var startrow = arrayRowIndex_Start[0];
							var endrow = arrayRowIndex_End[arrayRowIndex_End.length-1];
							var startcol = arrayColIndex_Start[0];
							var endcol = arrayColIndex_End[arrayColIndex_End.length-1];
							
							//If there are coordinate points in the multi-drag area while rotating the outermost coordinate, the following logic is executed.
							for(var i = startrow; i <= endrow; i++) 
							{	
								for (var j = startcol; j <= endcol; j++) 
								{
									for(var n = obj.selectstartrow[0]; n<=obj.selectendrow[0]; n++)
									{
										for(var p = 0; p < obj.selectendrow.length; p++)
										{
											for(var m = obj.selectstartcol[p]; m <= obj.selectendcol[p]; m++)
											{
												if(i == n && j == m)
												{
													var value = "";
													
													if(!this.gfnIsNull(obj.getCellValue(i, j)))
													{
														value = obj.getCellValue(i, j);
														
														if (j < endcol) 
															clipText += value + this.COL_SEPERATOR;
														else 
															clipText += value + this.COL_SEPERATOR;
														break;
													}
												}
											}
										}
									}
								}
								clipText += this.ROW_SEPERATOR;
							}
					    }
					}	
					//CTRL cell designation after dragging vertical area
					//When the row is different and col is the same
					else if(nFlag1 == 1 && nFlag2 == 0)
					{	
						var clipText = "";
						
						// When nFlag4 is 0: For one col
						// When nFlag4 is 1: For multiple cols
						for(var i=0; i<obj.selectstartcol.length; i++)
						{
							if(obj.selectstartcol[i] != obj.selectendcol[i])
								nFlag4 = 1;
						}
						
						if(nFlag4 == 0) 
						{
							//Sort in ascending order
							obj.selectstartrow.sort(function(left, right) {
								return left-right;
							});
							
							//Sort in ascending order
							obj.selectendrow.sort(function(left, right) {
								return left-right;
							});
							
							for(var k=0; k<obj.selectstartrow.length; k++)
							{
								for(var i=obj.selectstartrow[k]; i<=obj.selectendrow[k]; i++)
								{
									var value = "";
									
									if(!this.gfnIsNull(obj.getCellValue(i, obj.selectstartcol[k])))
									{
										value = obj.getCellValue(i, obj.selectstartcol[k]);
										clipText += value + this.ROW_SEPERATOR;
									}
								}
							}
						}
						else if(nFlag4 == 1) 
						{
							var temp = Math.abs(obj.selectendcol[0] - obj.selectstartcol[0]);
							
							for(var i=0; i<obj.selectstartcol.length; i++)
							{	
								if(i != 0)
								{
									if(temp != Math.abs(obj.selectendcol[i] - obj.selectstartcol[i]))
									{
										alert("This command is not available in multiple selection ranges.");
										//alert("다중 선택 범위에서는 사용할 수 없는 명령입니다.");
										return;
									}
								}
							}	
							
							for(var q=0; q<obj.selectstartrow.length; q++)
							{
								var startrow = obj.selectstartrow[q];
								var endrow = obj.selectendrow[q];
								var startcol = obj.selectstartcol[q];
								var endcol = obj.selectendcol[q];
								
								for(var i = startrow; i <= endrow; i++) 
								{
									for (var j = startcol; j <= endcol; j++) 
									{
										var value = "";
										
										if(!this.gfnIsNull(obj.getCellValue(i, j)))
										{
											value = obj.getCellValue(i, j);
											
											if(j < endcol) 
												clipText += value + this.COL_SEPERATOR;
											else 
												clipText += value + this.COL_SEPERATOR;
										}
									}
									clipText += this.ROW_SEPERATOR;
								}
						    }
						}
					}
					//CTRL cell only (incomplete)
					else
					{
						//alert("다중 선택 범위에서는 사용할 수 없는 명령입니다.");
						alert("This command is not available in multiple selection ranges.");
						return; 
						
						form.targetGrid = undefined;
						var clipText = "";
						
						// CTRL When multiple cells are clicked, the structures of selectstartrow, selectendrow, selectstartcol, and selectendcol are transferred to an array.
						// To execute the existing logic, the structure must be changed.
						var arrayRowIndex = new Array(); 
						var arrayColIndex = new Array(); 
						
						for(var i=0; i<obj.selectstartrow.length; i++)
						{
							arrayRowIndex.push(nexacro.toNumber(obj.selectstartrow[i]));
							arrayColIndex.push(nexacro.toNumber(obj.selectstartcol[i]));
						}
						
						//Sort in ascending order
						arrayRowIndex.sort(function(left, right) {
							return left-right;
						});
						
						//Sort in ascending order
						arrayColIndex.sort(function(left, right) {
							return left-right;
						});
						
						var startrow = arrayRowIndex[0];
						var endrow = arrayRowIndex[arrayRowIndex.length-1];
						var startcol = arrayColIndex[0];
						var endcol = arrayColIndex[arrayColIndex.length-1];
						
						for(var i = startrow; i <= endrow; i++) 
						{
							var nFlag = 0;
							
							for (var j = startcol; j <= endcol; j++) 
							{
								for(var pi=0; pi<obj.selectstartrow.length; pi++)
								{
									if(i == obj.selectstartrow[pi] && j == obj.selectstartcol[pi])
									{	
										nFlag = 1;
										var value = "";
										var colFlag = 0;
										
										if(!this.gfnIsNull(obj.getCellValue(i, j)))
											value = obj.getCellValue(i, j);
										else
											colFlag = 1;
										
										if (j < endcol && colFlag != 1) 
										{
											clipText += value + this.COL_SEPERATOR;
											colFlag = 0;
										}
										else 
											clipText += value + this.COL_SEPERATOR;
										break;
									}
									else 
										nFlag = 0;
								}
							}
							
							if(nFlag == 1)
								clipText += this.ROW_SEPERATOR;
						}
					}
					
					system.clearClipboard();
					system.setClipboard("CF_TEXT", clipText);
					
					form.targetGrid = obj;
				}
				else
				{
					var startrow = nexacro.toNumber(obj.selectstartrow);
					var endrow = nexacro.toNumber(obj.selectendrow);
					var startcol = nexacro.toNumber(obj.selectstartcol);
					var endcol = nexacro.toNumber(obj.selectendcol);
					
					var copyData = "";
					var checkIndex = {};
					
					form.targetGrid = null;
					
					for (var i = startrow; i <= endrow; i++) 
					{
						for (var j = startcol; j <= endcol; j++) 
						{
							if (!checkIndex[j]) 
							{
								checkIndex[j] = 1;
							}
							
							var value = obj.getCellValue(i, j);
							
							if (!this.gfn_isEmpty(value) && value != "undefined") 
							{
								if (j < obj.selectendcol) 
								{
									copyData += obj.getCellValue(i, j) + this.COL_SEPERATOR;
								}
								else 
								{
									copyData += obj.getCellValue(i, j);
								}
							}
						}
						
						if (i < obj.selectendrow) 
						{
							copyData += this.ROW_SEPERATOR;
						}
					}
					
					copyData += this.ROW_SEPERATOR;
					
					system.clearClipboard();
					system.setClipboard("CF_TEXT", copyData);
					
					form.targetGrid = obj;
				}
			}
			else if (keycode == 86) 
			{
				var copyData = system.getClipboard("CF_TEXT");
				copyData = new String(copyData);
				var rowData = copyData.split(this.ROW_SEPERATOR);
				var rowDataCount = rowData.length - 1;
				
				if (rowDataCount < 1) 
				{
					e.stopPropagation();
					return;
				}
				
				obj.set_enableevent(false);
				obj.set_enableredraw(false);
				
				var ds = obj.getBindDataset();
				ds.set_enableevent(false);
				
				var grdCellCount = obj.getCellCount("body");
				var rowCount = ds.getRowCount();
				
				var startrow = nexacro.toNumber(obj.selectstartrow);
				var endrow = nexacro.toNumber(obj.selectendrow);
				var startcol = nexacro.toNumber(obj.selectstartcol);
				var endcol = 0;
				
				var currRow = startrow;
				var cellIndex = startcol;
				var maxColumnCount = 0;
				
				var checkIndex = {};
				
				// check current cell editType
				for (var i = 0; i < rowDataCount; i++) 
				{
					if (rowCount <= currRow) 
					{
						ds.addRow();
					}
					
					var columnData = rowData[i].split(this.COL_SEPERATOR);
					var columnLoopCount = cellIndex + columnData.length;
					
					if (columnLoopCount > grdCellCount) 
					{
						columnLoopCount = grdCellCount;
					}
					
					if (maxColumnCount < columnLoopCount) 
					{
						maxColumnCount = columnLoopCount;
					}
					
					var k = 0;
					for (var j = cellIndex; j < columnLoopCount; j++) 
					{
						if (!checkIndex[j]) 
						{
							checkIndex[j] = 1;
						}
						
						var colid = obj.getCellProperty("body", j, "text").substr(5);
						var tempValue = columnData[k];
						if (!this.gfn_isEmpty(tempValue) && tempValue != "undefined") 
						{
							ds.setColumn(currRow, colid, tempValue);
						}
						
						k++;
					}
					currRow++;
				}
				
				ds.rowposition = currRow;
				
				endrow = endrow + rowDataCount - 1;
				endcol = maxColumnCount - 1;
				
				obj.set_enableredraw(true);
				obj.set_enableevent(true);
				ds.set_enableevent(true);
				
				obj.selectArea(startrow, startcol, endrow, endcol);
				
				form.targetGrid = obj;
				
				// When grid enableredraw is false
				// Processing to prevent errors from occurring during the propagation of events. 2015.02.25 version.
				e.stopPropagation();
			}
		}
	}
	else 
	{
		if (e.ctrlkey && !e.shiftkey && !e.altkey) 
		{
			if(keycode == 67) 
			{	
				if(this.rdoSelectType.value == "row" || this.rdoSelectType.value == "multirow")
				{
					var value="", clipText = "";
					
					//row
					if(obj.selectstartrow.length < 2 || obj.selectendrow.length < 2)
					{
						if(obj.selectendrow[0] > obj.selectstartrow[0])
						{
							//row(multirow)
							for(var i=obj.selectstartrow[0]; i<=obj.selectendrow[0]; i++)
							{
								for(var j=1; j<obj.getFormatColCount(); j++)
								{
									value = obj.getCellValue(i, j);
									clipText += value + this.COL_SEPERATOR;
								}
								clipText += this.ROW_SEPERATOR;
							}
						}
						else
						{
							//row
							for(var i=1; i<obj.getFormatColCount(); i++)
							{
								value = obj.getCellValue(obj.selectstartrow[0], i);
								clipText += value + this.COL_SEPERATOR;
							}
						}
					}
					//multirow
					else
					{	
						//Sort in ascending order: to print in order
						obj.selectstartrow.sort(function(left, right) {
							return left-right;
						});
						
						obj.selectendrow.sort(function(left, right) {
							return left-right;
						});
						
						for(var i=0; i<obj.selectstartrow.length; i++)
						{
							//When selecting single row in multirow
							if(obj.selectstartrow[i] == obj.selectendrow[i])
							{
								for(var j=1; j<obj.getFormatColCount(); j++)
								{
									value = obj.getCellValue(obj.selectstartrow[i], j);
									clipText += value + this.COL_SEPERATOR;
								}
								clipText += this.ROW_SEPERATOR;
							}
							//multirow to multi-row selection
							else
							{
								for(var j=obj.selectstartrow[i]; j<=obj.selectendrow[i]; j++)
								{
									for(var k=1; k<obj.getFormatColCount(); k++)
									{
										value = obj.getCellValue(j, k);
										clipText += value + this.COL_SEPERATOR;
									}
									clipText += this.ROW_SEPERATOR;
								}
							}
						}
					}
					
					form.targetGrid = obj;
					var ta = this._createTextarea(clipText);
					form.targetGrid["ta"] = ta;
					form.setTimer(777, 100);
					e.stopPropagation();
					
					return;
				}
				
				if(obj.selectstartrow.length >= 2 || obj.selectendrow.length >= 2 || obj.selectstartcol.length >= 2 || obj.selectendcol.length >= 2)
				{
					//Horizontal area designation variable
					var nFlag1 = 0, nFlag3 = 0;
					
					//Vertical area designation variable
					var nFlag2 = 0, nFlag4 = 0;
					
					//When nFlag1 is 1: Specify multiple rows
					//When nFlag1 is 0: Specify single row
					for(var i=1; i<obj.selectstartrow.length; i++)
					{
						if(obj.selectstartrow[0] != obj.selectstartrow[i])
							nFlag1 = 1;
					}
					
					//When nFlag2 is 1: Specify multiple columns
					//When nFlag2 is 0: single column designation
					for(var i=1; i<obj.selectstartcol.length; i++)
					{
						if(obj.selectstartcol[0] != obj.selectstartcol[i])
							nFlag2 = 1;
					}
					
					// When designating CTRL cell after dragging horizontal area
					// When the rows are the same and the cols are different
					if(nFlag1 == 0 && nFlag2 == 1) 
					{	
						var clipText = "";
						
						// when nFlag3 is 0: for one col
						// When nFlag3 is 1: For multiple cols
						for(var i=0; i<obj.selectstartrow.length; i++)
						{
							if(obj.selectstartrow[i] != obj.selectendrow[i])
								nFlag3 = 1;
						}
						
						if(nFlag3 == 0) 
						{	
							// Sort in ascending order: to print in order
							obj.selectstartcol.sort(function(left, right) {
								return left-right;
							});
							
							obj.selectendcol.sort(function(left, right) {
								return left-right;
							});
							
							for(var k=0; k<obj.selectstartcol.length; k++)
							{
								for(var i=obj.selectstartcol[k]; i<=obj.selectendcol[k]; i++)
								{
									var value = "";
									
									if(!this.gfnIsNull(obj.getCellValue(obj.selectstartrow[k], i)))
									{
										value = obj.getCellValue(obj.selectstartrow[k], i);
										clipText += value + this.COL_SEPERATOR;
									}
								}
							}
						}
						else if(nFlag3 == 1)
						{
							var temp = Math.abs(obj.selectendrow[0] - obj.selectstartrow[0]);
							
							var arrayRowIndex_Start = new Array();
							var arrayRowIndex_End = new Array();
							var arrayColIndex_Start = new Array(); 
							var arrayColIndex_End = new Array(); 
							
							for(var i=0; i<obj.selectstartrow.length; i++)
							{	
								if(i != 0)
								{
									if(temp != Math.abs(obj.selectendrow[i] - obj.selectstartrow[i]))
									{
										//alert("다중 선택 범위에서는 사용할 수 없는 명령입니다.");
										alert("This command is not available in multiple selection ranges.");
										return;
									}
								}
							}	
							
							for(var i=0; i<obj.selectstartrow.length; i++)
							{
								arrayRowIndex_Start.push(nexacro.toNumber(obj.selectstartrow[i]));
								arrayRowIndex_End.push(nexacro.toNumber(obj.selectendrow[i]));
								arrayColIndex_Start.push(nexacro.toNumber(obj.selectstartcol[i]));
								arrayColIndex_End.push(nexacro.toNumber(obj.selectendcol[i]));
							}
							
							//Sort in ascending order: to get the outermost coordinates.
							arrayRowIndex_Start.sort(function(left, right) {
								return left-right;
							});
							
							arrayRowIndex_End.sort(function(left, right) {
								return left-right;
							});
							
							arrayColIndex_Start.sort(function(left, right) {
								return left-right;
							});
							
							arrayColIndex_End.sort(function(left, right) {
								return left-right;
							});
							
							var startrow = arrayRowIndex_Start[0];
							var endrow = arrayRowIndex_End[arrayRowIndex_End.length-1];
							var startcol = arrayColIndex_Start[0];
							var endcol = arrayColIndex_End[arrayColIndex_End.length-1];
							
							//If there are coordinate points in the multi-drag area while rotating the outermost coordinate, the following logic is executed.
							for(var i = startrow; i <= endrow; i++) 
							{	
								for (var j = startcol; j <= endcol; j++) 
								{
									for(var n = obj.selectstartrow[0]; n<=obj.selectendrow[0]; n++)
									{
										for(var p = 0; p < obj.selectendrow.length; p++)
										{
											for(var m = obj.selectstartcol[p]; m <= obj.selectendcol[p]; m++)
											{
												if(i == n && j == m)
												{
													var value = "";
													
													if(!this.gfnIsNull(obj.getCellValue(i, j)))
													{
														value = obj.getCellValue(i, j);
													
														if (j < endcol) 
															clipText += value + this.COL_SEPERATOR;
														else 
															clipText += value + this.COL_SEPERATOR;
														break;
													}
												}
											}
										}
									}
								}
								clipText += this.ROW_SEPERATOR;
							}
					    }
					}	
					// Specify CTRL cell after dragging vertical area
					// When the rows are different and cols are the same
					else if(nFlag1 == 1 && nFlag2 == 0)
					{	
						var clipText = "";
						
						// When nFlag4 is 0: For one col
						// When nFlag4 is 1: For multiple cols
						for(var i=0; i<obj.selectstartcol.length; i++)
						{
							if(obj.selectstartcol[i] != obj.selectendcol[i])
								nFlag4 = 1;
						}
						
						if(nFlag4 == 0) 
						{
							//Sort in ascending order
							obj.selectstartrow.sort(function(left, right) {
								return left-right;
							});
							
							//Sort in ascending order
							obj.selectendrow.sort(function(left, right) {
								return left-right;
							});
							
							for(var k=0; k<obj.selectstartrow.length; k++)
							{
								for(var i=obj.selectstartrow[k]; i<=obj.selectendrow[k]; i++)
								{
									var value = "";
									
									if(!this.gfnIsNull(obj.getCellValue(i, obj.selectstartcol[k])))
									{
										value = obj.getCellValue(i, obj.selectstartcol[k]);
										clipText += value + this.ROW_SEPERATOR;
									}
								}
							}
						}
						else if(nFlag4 == 1) 
						{
							var temp = Math.abs(obj.selectendcol[0] - obj.selectstartcol[0]);
							
							for(var i=0; i<obj.selectstartcol.length; i++)
							{	
								if(i != 0)
								{
									if(temp != Math.abs(obj.selectendcol[i] - obj.selectstartcol[i]))
									{
										alert("다중 선택 범위에서는 사용할 수 없는 명령입니다.");
										return;
									}
								}
							}	
							
							for(var q=0; q<obj.selectstartrow.length; q++)
							{
								var startrow = obj.selectstartrow[q];
								var endrow = obj.selectendrow[q];
								var startcol = obj.selectstartcol[q];
								var endcol = obj.selectendcol[q];
								
								for(var i = startrow; i <= endrow; i++) 
								{
									for (var j = startcol; j <= endcol; j++) 
									{
										var value = "";
										
										if(!this.gfnIsNull(obj.getCellValue(i, j)))
										{
											value = obj.getCellValue(i, j);
										
											if(j < endcol) 
												clipText += value + this.COL_SEPERATOR;
											else 
												clipText += value + this.COL_SEPERATOR;
										}
									}
									clipText += this.ROW_SEPERATOR;
								}
						    }
						}
					}
					//CTRL cell only (incomplete)
					else
					{
						//alert("다중 선택 범위에서는 사용할 수 없는 명령입니다.");
						alert ("This command is not available in multiple selections.");
						return; 
						
						form.targetGrid = undefined;
						var clipText = "";
						
						// CTRL When multiple cells are clicked, the structures of selectstartrow, selectendrow, selectstartcol, and selectendcol are transferred to an array.
						// To execute the existing logic, the structure must be changed.
						var arrayRowIndex = new Array(); 
						var arrayColIndex = new Array(); 
						
						for(var i=0; i<obj.selectstartrow.length; i++)
						{
							arrayRowIndex.push(nexacro.toNumber(obj.selectstartrow[i]));
							arrayColIndex.push(nexacro.toNumber(obj.selectstartcol[i]));
						}
						
						// Sort in ascending order
						arrayRowIndex.sort(function(left, right) {
							return left-right;
						});
						
						// Sort in ascending order
						arrayColIndex.sort(function(left, right) {
							return left-right;
						});
						
						var startrow = arrayRowIndex[0];
						var endrow = arrayRowIndex[arrayRowIndex.length-1];
						var startcol = arrayColIndex[0];
						var endcol = arrayColIndex[arrayColIndex.length-1];
						
						for(var i = startrow; i <= endrow; i++) 
						{
							var nFlag = 0;
							
							for (var j = startcol; j <= endcol; j++) 
							{
								for(var pi=0; pi<obj.selectstartrow.length; pi++)
								{
									if(i == obj.selectstartrow[pi] && j == obj.selectstartcol[pi])
									{	
										nFlag = 1;
										var value = "";
										var colFlag = 0;
										
										if(!this.gfnIsNull(obj.getCellValue(i, j)))
											value = obj.getCellValue(i, j);
										else
											colFlag = 1;
										
										if (j < endcol && colFlag != 1) 
										{
											clipText += value + this.COL_SEPERATOR;
											colFlag = 0;
										}
										else 
											clipText += value + this.COL_SEPERATOR;
										break;
									}
									else 
										nFlag = 0;
								}
							}
							
							if(nFlag == 1)
								clipText += this.ROW_SEPERATOR;
						}
					}
					
					form.targetGrid = obj;
					var ta = this._createTextarea(clipText);
					form.targetGrid["ta"] = ta;
					form.setTimer(777, 100);
					e.stopPropagation();
				}
				else
				{	
					var startrow = nexacro.toNumber(obj.selectstartrow);
					var endrow = nexacro.toNumber(obj.selectendrow);
					var startcol = nexacro.toNumber(obj.selectstartcol);
					var endcol = nexacro.toNumber(obj.selectendcol);
					
					var checkIndex = {};
					
					form.targetGrid = undefined;
					
					var clipText = "";
					
					for (var i = startrow; i <= endrow; i++) 
					{	
						for (var j = startcol; j <= endcol; j++) 
						{
							var value = "";
							var colFlag = 0;
							
							if(!this.gfnIsNull(obj.getCellValue(i, j)))
							{
								value = obj.getCellValue(i, j);
							}
							else
								colFlag = 1;
							
							if (j < endcol && colFlag != 1) 
							{
								clipText += value + this.COL_SEPERATOR;
								colFlag = 0;
							}
							
							else 
							{
								clipText += value;
							}
						}
						
						clipText += this.ROW_SEPERATOR;
					}
					
					form.targetGrid = obj;
					var ta = this._createTextarea(clipText);
					form.targetGrid["ta"] = ta;
					form.setTimer(777, 100);
					e.stopPropagation();
				}
			}
			else if (keycode == 86) 
			{	
				form.targetGrid = obj;
				form.targetEvent = e;
				
				var ta = this._createTextarea('');
				form.targetGrid["ta"] = ta;
				
				form.setTimer(888, 100);
				
				e.stopPropagation();
			}
		}
	}
};

/**
* Grid Copy Timer Event
* @param {Form} obj Form Component where the event occurred
* @param {TimerEventInfo} e TimerEventInfo
* @memberOf nxlib.grid
*/

this.gridCopyTimerHandler = function (obj, e)
{
	if (nexacro._browser == "Runtime" || nexacro._browser == "IE") 
	{
	}
	else 
	{
		var timerid = e.timerid;
		obj.killTimer(timerid);
		
		if (timerid == 777) 
		{
			var ta = obj.targetGrid["ta"];
			
			if (!ta) 
			{
				return;
			}
			
			document.body.removeChild(ta);
			obj.targetGrid["ta"] = undefined;
		}
		else if (timerid == 888) 
		{	
			var ta = obj.targetGrid["ta"];
			
			if (!ta) 
			{
				return;
			}
			
			var clipText = ta.value;
			document.body.removeChild(ta);
			this.pasteData(obj, clipText);
			
			obj.targetGrid["ta"] = undefined;
		}
	}
};

/**
* Textarea creation function
* @param {String} innerText Text to copy
* @memberOf nxlib.grid
*/

this._createTextarea = function (innerText)
{	
	var ta = document.createElement('textarea');
	ta.style.position = 'absolute';
	ta.style.left = '-1000px';
	ta.style.top = document.body.scrollTop + 'px';
	ta.value = innerText;
	document.body.appendChild(ta);
	ta.select();
	
	return ta;
};

/**
* paste
* @param {Form} form Form object
* @param {string} clipText Text to paste
* @memberOf nxlib.grid
*/

this.pasteData = function (form, clipText)
{
	var obj = form.targetGrid;
	
	obj.set_enableevent(false);
	obj.set_enableredraw(false);
	
	var ds = obj.getBindDataset();
	ds.set_enableevent(false);
	
	var grdCellCount = obj.getCellCount("body");
	var rowCount = ds.getRowCount();
	var startrow = nexacro.toNumber(obj.selectstartrow),endrow = nexacro.toNumber(obj.selectendrow),startcol = nexacro.toNumber(obj.selectstartcol),endcol = nexacro.toNumber(obj.selectendcol);
	
	var currRow = startrow;
	var cellIndex = startcol;
	
	copyData = clipText;
	
	var rowData = copyData.split(/[\n\f\r]/);
	var rowDataCount = rowData.length - 1;
	
	var checkIndex = {
		
	};
	
	for (var i = 0; i < rowDataCount; i++) 
	{
		if (rowCount <= currRow) 
		{
			ds.addRow();
		}
		
		var columnData = rowData[i].split(this.COL_SEPERATOR);
		var columnLoopCount = cellIndex + columnData.length;
		
		if (columnLoopCount > grdCellCount) 
		{
			columnLoopCount = grdCellCount;
		}
		
		var k = 0;
		for (var j = cellIndex; j < columnLoopCount; j++) 
		{
			if (!checkIndex[j]) 
			{
				checkIndex[j] = 1;
			}
			
			var colid = obj.getCellProperty("body", j, "text").substr(5);
			var tempValue = columnData[k];
			if (!this.gfn_isEmpty(tempValue) && tempValue != "undefined") 
			{
				ds.setColumn(currRow, colid, tempValue);
			}
			
			k++;
		}
		
		currRow++;
	}
	
	ds.rowposition = currRow;
	
	endrow = endrow + rowDataCount - 1;
	endcol = columnLoopCount - 1;
	
	obj.set_enableredraw(true);
	obj.set_enableevent(true);
	ds.set_enableevent(true);
	
	obj.selectArea(startrow, startcol, endrow, endcol);
};

/**
* alphabet character code.
* @private
* @constant
* @memberOf Base
*/
_ALPHA_CHAR_CODES = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70]

/**
* Returns whether value is empty.
* <pre>
* 1. null, undefined type : true return
* 2. string, array type : Returns true if length is 0
* 3. object type : Returns true if sub-attributes exist
* 4. boolean, number, date type : return false
* </pre>
* @param {*} value The value to check.
* @return {boolean} empty or not.
*/

this.gfn_isEmpty = function (value)
{
	// null, undefined ==> true
	if (value === null || value === undefined) return true;
	
	// String, Array ==> length == 0
	if ( this.gfn_isString(value) || this.gfn_isArray(value) )
	{
		return value.length == 0 ? true : false;
	}
	else if ( this.gfn_isObject(value) )
	{
		for (var p in value) 
		{
			if ( value.hasOwnProperty(p) )
			{
				return false;
			}
		}
		return true;
	}
	
	return false;
}


/**
* Returns whether value is a string
* @param {*} value The value to check.
* @return {boolean} string.
*/

this.gfn_isString = function(value) 
{
	return typeof value === 'string';
}

/**
* Returns whether the value is an Array.
* @param {*} value The value to check.
* @return {boolean} Array.
*/
this.gfn_isArray = function(value) 
{
	//TODO
	/*
	Let's do something like this in V13 (or HTML5)
	return Object.prototype.toString.call( value ) === '[object Array]';
	*/
	
	if ( value === null || value === undefined ) return false;
	
	// XP Comp generates an error when accessing the constructor
	//if ( this.gfn_isXpComponent(value) ) return false;
	
	return typeof value == "object" && 
	'constructor' in value &&
	value.constructor === Array;
}

/**
* Returns whether the value is XPLATFORM component.
* @param {*} value The value to check.
* @return {boolean} Whether to use XPLATFORM component.
*/

this.gfn_isXpComponent = function(value) 
{
	if ( value === null || value === undefined  ) return false;
	
	// 9.2 Common properties in Runtime based on XP Comp are style
	return ( 'style' in value ) && 
	( typeof value.style == 'object' ) &&
	( value.style.toString() == '[object StyleObject]' );
}

/**
* Returns whether the value is an object.
* @param {*} value The value to check.
* @return {boolean} Object.
*/

this.gfn_isObject = function(value)
{
	if ( value === null || value === undefined ) return false;
	
	// XP Comp generates an error when accessing the constructor
	//if ( this.gfn_isXpComponent(value) ) return false;
	
	return typeof value == "object" && 
	'constructor' in value &&
	value.constructor === Object;
}


]]></Script>
  </Form>
</FDL>
